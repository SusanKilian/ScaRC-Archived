MODULE SCARC_MPI
  
USE GLOBAL_CONSTANTS
USE PRECISION_PARAMETERS, ONLY: EB, FB
USE MEMORY_FUNCTIONS, ONLY: CHKMEMERR
USE COMP_FUNCTIONS, ONLY: CURRENT_TIME
USE MPI
USE SCARC_CONSTANTS
USE SCARC_VARIABLES
USE SCARC_TYPES
USE SCARC_UTILITIES
USE SCARC_ERROR_MANAGER
USE SCARC_MEMORY_MANAGER
USE SCARC_MESSAGE_SERVICES, ONLY: MSG
USE SCARC_TIME_MEASUREMENT, ONLY: CPU

CONTAINS

! ------------------------------------------------------------------------------------------------
!> \brief Setup neighborship structure for data exchanges along mesh interfaces
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_SETUP_NEIGHBORS
USE SCARC_POINTERS, ONLY: OS, OLF, OLC
INTEGER :: NM, NOM, NL

! Initialize communication counter for ScaRC, use same TAG for all communications
TAG   = 99
N_REQ =  0
N_EXCHANGES = 0

! Initialize level structures on neighboring meshes
 
LEVEL_MESHES_LOOP: DO NM = LOWER_MESH_INDEX, UPPER_MESH_INDEX

   LEVEL_NEIGHBOR_LOOP: DO NOM = 1, NMESHES

 
      ! On finest level point to exchange structures from surrounding FDS 
 
      IF (.NOT. ARE_NEIGHBORS(NM, NOM)) CYCLE LEVEL_NEIGHBOR_LOOP

      N_EXCHANGES = N_EXCHANGES+1                                         ! count number of exchanges

      OS => SCARC(NM)%OSCARC(NOM)
      ALLOCATE (OS%LEVEL(NLEVEL_MIN:NLEVEL_MAX), STAT=IERROR)             ! allocate neighboring structures
      CALL CHKMEMERR ('SCARC_SETUP_NEIGHBORS', 'OS%LEVEL', IERROR)

      OLF => SCARC(NM)%OSCARC(NOM)%LEVEL(NLEVEL_MIN)                      ! point to neighbor on finest grid level

      OLF%NX = MESHES(NOM)%IBAR                                           ! number of cells in x-direction on neighbor
      OLF%NY = MESHES(NOM)%JBAR                                           ! number of cells in y-direction on neighbor
      OLF%NZ = MESHES(NOM)%KBAR                                           ! number of cells in z-direction on neighbor

      OLF%N_WALL_CELLS_EXT = MESHES(NOM)%N_EXTERNAL_WALL_CELLS            ! number of external wall cells on neighbor
      OLF%N_WALL_CELLS_INT = MESHES(NOM)%N_INTERNAL_WALL_CELLS            ! number of external wall cells on neighbor
      OLF%N_WALL_CELLS     = OLF%N_WALL_CELLS_EXT + OLF%N_WALL_CELLS_INT  ! number of walls cell on neighbor

      OLF%N_CELLS = OLF%NX*OLF%NY*OLF%NZ                                  ! number of cells on neighbor (structured)

 
      ! In case of GMG with a predefined grid hierarchy define corresponding level-structures
 
      IF (NLEVEL_MAX > NLEVEL_MIN) THEN                                   

         DO NL=NLEVEL_MIN+1,NLEVEL_MAX

            OLC => SCARC(NM)%OSCARC(NOM)%LEVEL(NL)                        ! OLF points to finer, OLC to coarser level

            OLC%NX = OLF%NX/2                                             ! use double grid width
            IF (TWO_D) THEN
               OLC%NY = 1
            ELSE
               OLC%NY = OLF%NY/2
            ENDIF
            OLC%NZ = OLF%NZ/2

            OLC%N_CELLS          = OLC%NX * OLC%NY * OLC%NZ               ! set new number of cells
            OLC%N_WALL_CELLS     = OLC%N_WALL_CELLS_EXT                   ! set new number of wall cells
            OLC%N_WALL_CELLS_EXT = 2 * (OLC%NX*OLC%NZ + OLC%NX*OLC%NY + OLC%NY*OLC%NZ)    ! TODO: CHECK!

         ENDDO
      ENDIF

   ENDDO LEVEL_NEIGHBOR_LOOP
ENDDO LEVEL_MESHES_LOOP

END SUBROUTINE SCARC_SETUP_NEIGHBORS

! ------------------------------------------------------------------------------------------------
!> \brief Allocate workspace for data exchanges of different data types and sizes and perform basic exchanges
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_SETUP_EXCHANGES
USE SCARC_POINTERS, ONLY:  S, OS, OL, OG, OGF
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_GRID, SCARC_POINT_TO_OTHER_GRID
INTEGER :: NL, NM, NOM, NLEN
INTEGER :: INBR

CROUTINE = 'SCARC_SETUP_EXCHANGES'
 
! Allocate request array for data exchanges
! Exchange basic information about wall sizes (needed for the dimensioning of the exchange buffers)
 
IF (N_MPI_PROCESSES>1) THEN
   ALLOCATE (REQ(N_EXCHANGES*40), STAT=IERROR)
   CALL CHKMEMERR ('SCARC_SETUP_EXCHANGES', 'REQ', IERROR)
   REQ = MPI_REQUEST_NULL
ENDIF
CALL SCARC_EXCHANGE (NSCARC_EXCHANGE_BASIC_SIZES, NSCARC_NONE, NLEVEL_MIN)

 
! Allocate send and receive buffers (real and integer) in correct lengths
! These are allocated with sizes according to the requirements of the finest grid level
! In case of a multi-level method, they are also used for the coarser levels (with shorter exchange sizes)

DO NM = LOWER_MESH_INDEX, UPPER_MESH_INDEX

   DO INBR = 1, SCARC(NM)%N_NEIGHBORS

      CALL SCARC_POINT_TO_GRID(NM, NLEVEL_MIN)                          

      NOM = S%NEIGHBORS(INBR)
      CALL SCARC_POINT_TO_OTHER_GRID(NM, NOM, NLEVEL_MIN)

      ! Allocate buffers in maximum length for finest grid level (same buffers are used in shorter length on coarse levels, too)

      IF (.NOT.IS_MGM) THEN
   
         OS%NLEN_MAX_BUFFER_LAYER1  = MAX(OS%NLEN_MAX_BUFFER_LAYER1, (OG%NCG+1) * 1)
         OS%NLEN_MAX_BUFFER_LAYER2  = MAX(OS%NLEN_MAX_BUFFER_LAYER2, (OG%NCG+1) * 2)
         OS%NLEN_MAX_BUFFER_LAYER4  = MAX(OS%NLEN_MAX_BUFFER_LAYER2, (OG%NCG+1) * 4)
         OS%NLEN_MAX_BUFFER_STENCIL = MAX(OS%NLEN_MAX_BUFFER_LAYER2, (OG%NCG+1) * NSCARC_MAX_STENCIL)
         OS%NLEN_MAX_BUFFER_FULL    = MAX(OS%NLEN_MAX_BUFFER_LAYER2, (OG%NCG+1) * NSCARC_MAX_STENCIL * 4)

         OG%NLEN_BUFFER_LAYER1  = OS%NLEN_MAX_BUFFER_LAYER1
         OG%NLEN_BUFFER_LAYER2  = OS%NLEN_MAX_BUFFER_LAYER2
         OG%NLEN_BUFFER_LAYER4  = OS%NLEN_MAX_BUFFER_LAYER4
         OG%NLEN_BUFFER_STENCIL = OS%NLEN_MAX_BUFFER_STENCIL
         OG%NLEN_BUFFER_FULL    = OS%NLEN_MAX_BUFFER_FULL

         NLEN = 2*OS%NLEN_MAX_BUFFER_FULL 
   
         CALL SCARC_ALLOCATE_INT1 (OS%SEND_BUFFER_INT , 1, NLEN, NSCARC_INIT_HUGE, 'OS%SEND_BUFFER_INT', CROUTINE)
         CALL SCARC_ALLOCATE_INT1 (OS%RECV_BUFFER_INT , 1, NLEN, NSCARC_INIT_HUGE, 'OS%RECV_BUFFER_INT', CROUTINE)
         CALL SCARC_ALLOCATE_REAL1(OS%SEND_BUFFER_REAL, 1, NLEN, NSCARC_INIT_HUGE, 'OS%SEND_BUFFER_REAL', CROUTINE)
         CALL SCARC_ALLOCATE_REAL1(OS%RECV_BUFFER_REAL, 1, NLEN, NSCARC_INIT_HUGE, 'OS%RECV_BUFFER_REAL', CROUTINE)

      ELSE

         OGF => OL%UNSTRUCTURED

         OS%NLEN_MAX_BUFFER_LAYER1  = MAX(OS%NLEN_MAX_BUFFER_LAYER1, (OGF%NCG+1) * 1)
         OS%NLEN_MAX_BUFFER_LAYER2  = MAX(OS%NLEN_MAX_BUFFER_LAYER2, (OGF%NCG+1) * 2)
         OS%NLEN_MAX_BUFFER_LAYER4  = MAX(OS%NLEN_MAX_BUFFER_LAYER2, (OGF%NCG+1) * 4)
         OS%NLEN_MAX_BUFFER_STENCIL = MAX(OS%NLEN_MAX_BUFFER_LAYER2, (OGF%NCG+1) * NSCARC_MAX_STENCIL)
         OS%NLEN_MAX_BUFFER_FULL    = MAX(OS%NLEN_MAX_BUFFER_LAYER2, (OGF%NCG+1) * NSCARC_MAX_STENCIL * 4)

         OGF%NLEN_BUFFER_LAYER1  = OS%NLEN_MAX_BUFFER_LAYER1
         OGF%NLEN_BUFFER_LAYER2  = OS%NLEN_MAX_BUFFER_LAYER2
         OGF%NLEN_BUFFER_LAYER4  = OS%NLEN_MAX_BUFFER_LAYER4
         OGF%NLEN_BUFFER_STENCIL = OS%NLEN_MAX_BUFFER_STENCIL
         OGF%NLEN_BUFFER_FULL    = OS%NLEN_MAX_BUFFER_FULL

         OGF => OL%STRUCTURED

         OS%NLEN_MAX_BUFFER_LAYER1  = MAX(OS%NLEN_MAX_BUFFER_LAYER1, (OGF%NCG+1) * 1)
         OS%NLEN_MAX_BUFFER_LAYER2  = MAX(OS%NLEN_MAX_BUFFER_LAYER2, (OGF%NCG+1) * 2)
         OS%NLEN_MAX_BUFFER_LAYER4  = MAX(OS%NLEN_MAX_BUFFER_LAYER2, (OGF%NCG+1) * 4)
         OS%NLEN_MAX_BUFFER_STENCIL = MAX(OS%NLEN_MAX_BUFFER_LAYER2, (OGF%NCG+1) * NSCARC_MAX_STENCIL)
         OS%NLEN_MAX_BUFFER_FULL    = MAX(OS%NLEN_MAX_BUFFER_LAYER2, (OGF%NCG+1) * NSCARC_MAX_STENCIL * 4)

         OGF%NLEN_BUFFER_LAYER1  = OS%NLEN_MAX_BUFFER_LAYER1
         OGF%NLEN_BUFFER_LAYER2  = OS%NLEN_MAX_BUFFER_LAYER2
         OGF%NLEN_BUFFER_LAYER4  = OS%NLEN_MAX_BUFFER_LAYER4
         OGF%NLEN_BUFFER_STENCIL = OS%NLEN_MAX_BUFFER_STENCIL
         OGF%NLEN_BUFFER_FULL    = OS%NLEN_MAX_BUFFER_FULL

         NLEN = 2*OS%NLEN_MAX_BUFFER_FULL 
   
         CALL SCARC_ALLOCATE_INT1 (OS%SEND_BUFFER_INT , 1, NLEN, NSCARC_INIT_HUGE, 'OS%SEND_BUFFER_INT', CROUTINE)
         CALL SCARC_ALLOCATE_INT1 (OS%RECV_BUFFER_INT , 1, NLEN, NSCARC_INIT_HUGE, 'OS%RECV_BUFFER_INT', CROUTINE)
         CALL SCARC_ALLOCATE_REAL1(OS%SEND_BUFFER_REAL, 1, NLEN, NSCARC_INIT_HUGE, 'OS%SEND_BUFFER_REAL', CROUTINE)
         CALL SCARC_ALLOCATE_REAL1(OS%RECV_BUFFER_REAL, 1, NLEN, NSCARC_INIT_HUGE, 'OS%RECV_BUFFER_REAL', CROUTINE)
      ENDIF
     

#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,*) 'ALLOCATING SEND_BUFFERS IN LENGtH ', NLEN, OG%NCG, NSCARC_MAX_STENCIL
#endif

      ! Neighboring wall structures for common wall cells
      ALLOCATE (OG%WALL(OG%NCG), STAT=IERROR)
      CALL CHKMEMERR ('SCARC_SETUP_NEIGHBORS', 'OG%WALL', IERROR)

      ! In case of GMG with a predefined grid hierarchy allocate corresponding level-structures

      IF (NLEVEL_MAX > NLEVEL_MIN) THEN
         DO NL=NLEVEL_MIN+1,NLEVEL_MAX
            CALL SCARC_POINT_TO_OTHER_GRID(NM, NOM, NL)
            ALLOCATE (OG%WALL(OG%NCG), STAT=IERROR)
            CALL CHKMEMERR ('SCARC_SETUP_NEIGHBORS', 'OG%WALL', IERROR)
         ENDDO
      ENDIF

   ENDDO
ENDDO

 
! If there is more than 1 mesh, initialize communication structures on finest level 
! and setup mapping from local to global numbering
 
IF (NMESHES > 1) THEN

   IF (IS_MGM) CALL SCARC_SETUP_GRID_TYPE(NSCARC_GRID_STRUCTURED)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,*) 'SETTING UP EXCHANGE_CELL_NUMBERS, TYPE_GRID =', TYPE_GRID
#endif
   CALL SCARC_EXCHANGE (NSCARC_EXCHANGE_CELL_NUMBERS, NSCARC_NONE, NLEVEL_MIN)
   CALL SCARC_EXCHANGE (NSCARC_EXCHANGE_CELL_SIZES,   NSCARC_NONE, NLEVEL_MIN)

   IF (HAS_MULTIPLE_LEVELS .AND. .NOT.HAS_AMG_LEVELS) THEN
      DO NL = NLEVEL_MIN+1, NLEVEL_MAX

         DO NM = LOWER_MESH_INDEX, UPPER_MESH_INDEX
            DO INBR = 1, SCARC(NM)%N_NEIGHBORS
      
               CALL SCARC_POINT_TO_GRID(NM, NLEVEL_MIN)                          
               NOM = S%NEIGHBORS(INBR)
               CALL SCARC_POINT_TO_OTHER_GRID(NM, NOM, NL)
   
               OG%NLEN_BUFFER_LAYER1  = MAX(OG%NLEN_BUFFER_LAYER1,  (OG%NCG+1) * 1)
               OG%NLEN_BUFFER_LAYER2  = MAX(OG%NLEN_BUFFER_LAYER2,  (OG%NCG+1) * 2)
               OG%NLEN_BUFFER_LAYER4  = MAX(OG%NLEN_BUFFER_LAYER4,  (OG%NCG+1) * 4)
               OG%NLEN_BUFFER_STENCIL = MAX(OG%NLEN_BUFFER_STENCIL, (OG%NCG+1) * NSCARC_MAX_STENCIL)
               OG%NLEN_BUFFER_FULL    = MAX(OG%NLEN_BUFFER_FULL,    (OG%NCG+1) * NSCARC_MAX_STENCIL * 4)
   
            ENDDO
          ENDDO

         CALL SCARC_EXCHANGE (NSCARC_EXCHANGE_CELL_NUMBERS, NSCARC_NONE, NL)
         CALL SCARC_EXCHANGE (NSCARC_EXCHANGE_CELL_SIZES,   NSCARC_NONE, NL)
      ENDDO
   ENDIF

ENDIF

END SUBROUTINE SCARC_SETUP_EXCHANGES


! ------------------------------------------------------------------------------------------------
!> \brief Perform data exchange corresponding to requested exchange type 
! 
! NSCARC_EXCHANGE_BASIC_SIZES     :  exchange initial information about interface sizes
! NSCARC_EXCHANGE_CELL_NEIGHBORS  :  exchange neighboring cell numbers on overlap
! NSCARC_EXCHANGE_CELL_NUMBERS    :  exchange neighboring grid widths on overlap
! NSCARC_EXCHANGE_CELL_SIZES      :  exchange neighboring grid widths on overlap
! NSCARC_EXCHANGE_MATRIX_COLS     :  exchange columns of neighboring matrix on overlap
! NSCARC_EXCHANGE_MATRIX_COLSG    :  exchange columns of neighboring matrix on overlap
! NSCARC_EXCHANGE_MATRIX_DIAGS    :  exchange size of neighboring matrix 
! NSCARC_EXCHANGE_MATRIX_SIZES    :  exchange size of neighboring matrix 
! NSCARC_EXCHANGE_MATRIX_VALS     :  exchange values of neighboring matrix on overlap
! NSCARC_EXCHANGE_NULLSPACE       :  exchange sum of nullspace entries
! NSCARC_EXCHANGE_PRESSURE        :  exchange vector values along internal boundaries
! NSCARC_EXCHANGE_VECTOR_MEAN     :  exchange vector and build mean values with own data
! NSCARC_EXCHANGE_VECTOR_PLAIN    :  exchange plain vector (just use data from neighbor)
! NSCARC_EXCHANGE_ZONE_NEIGHBORS  :  exchange number of aggregation zones (AMG only)
! NSCARC_EXCHANGE_ZONE_TYPES      :  exchange aggregation zone types (AMG only)
! 
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_EXCHANGE (NTYPE, NPARAM, NL)
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_GRID, SCARC_POINT_TO_OTHER_GRID
INTEGER, INTENT(IN) :: NTYPE, NPARAM, NL
REAL(EB) :: TNOW
INTEGER :: NM, NOM

N_REQ = 0
TYPE_EXCHANGE = NTYPE

 
! ---------- Receive data from neighbors 
 
RECEIVE_MESHES_LOOP: DO NM = LOWER_MESH_INDEX, UPPER_MESH_INDEX

   CALL SCARC_POINT_TO_GRID (NM, NL)             

   RECEIVE_OMESHES_LOOP: DO NOM = 1, NMESHES

      RNODE = PROCESS(NM)
      SNODE = PROCESS(NOM)

      IF (RNODE==SNODE .OR.  .NOT.ARE_NEIGHBORS(NM, NOM)) CYCLE RECEIVE_OMESHES_LOOP
      CALL SCARC_POINT_TO_OTHER_GRID(NM, NOM, NL)

      SELECT_EXCHANGE_TYPE: SELECT CASE (NTYPE)

         CASE (NSCARC_EXCHANGE_AUXILIARY)
            CALL SCARC_RECV_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER2, 'AUXILIARY')

         CASE (NSCARC_EXCHANGE_BASIC_SIZES)
            CALL SCARC_RECV_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_BASIC, 'BASIC SIZES')

         CASE (NSCARC_EXCHANGE_CELL_NEIGHBORS)
            CALL SCARC_RECV_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_LAYER4, 'CELL NEIGHBORS')

         CASE (NSCARC_EXCHANGE_CELL_NUMBERS)
            CALL SCARC_RECV_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'CELL NUMBERS')

         CASE (NSCARC_EXCHANGE_CELL_SIZES)
            CALL SCARC_RECV_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_BASIC, 'CELL SIZES')

         CASE (NSCARC_EXCHANGE_NULLSPACE)
            CALL SCARC_RECV_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER2, 'NULLSPACE')

         CASE (NSCARC_EXCHANGE_MATRIX_COLS)
            CALL SCARC_RECV_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_FULL, 'POISSON COLS')

         CASE (NSCARC_EXCHANGE_MATRIX_COLSG)
            CALL SCARC_RECV_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_FULL, 'POISSON COLSG')

         CASE (NSCARC_EXCHANGE_MATRIX_DIAGS)
            CALL SCARC_RECV_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'POISSON DIAGS')

         CASE (NSCARC_EXCHANGE_MATRIX_SIZES)
            CALL SCARC_RECV_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_BASIC, 'POISSON SIZES')

         CASE (NSCARC_EXCHANGE_MATRIX_VALS)
            CALL SCARC_RECV_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_FULL, 'POISSON VALS')

         CASE (NSCARC_EXCHANGE_PRESSURE)
            CALL SCARC_RECV_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'PRESSURE')

         CASE (NSCARC_EXCHANGE_MGM_TRUE)
            CALL SCARC_RECV_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER2, 'MGM_TRUE')

         CASE (NSCARC_EXCHANGE_MGM_MEAN)
            CALL SCARC_RECV_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'MGM_MEAN')

         CASE (NSCARC_EXCHANGE_MGM_VELO)
            CALL SCARC_RECV_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER2, 'MGM_VELO')

         CASE (NSCARC_EXCHANGE_LAYER2_NUMS)
            CALL SCARC_RECV_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'LAYER2_NUMS')

         CASE (NSCARC_EXCHANGE_LAYER2_VALS)
            CALL SCARC_RECV_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'LAYER2_VALS')

         CASE (NSCARC_EXCHANGE_VECTOR_MEAN)
            CALL SCARC_RECV_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER2, 'VECTOR MEAN')

         CASE (NSCARC_EXCHANGE_VECTOR_PLAIN)
            CALL SCARC_RECV_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'VECTOR PLAIN')

         CASE (NSCARC_EXCHANGE_ZONE_NEIGHBORS)
            CALL SCARC_RECV_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_LAYER4, 'ZONE NEIGHBORS')

         CASE (NSCARC_EXCHANGE_ZONE_TYPES)
            CALL SCARC_RECV_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_LAYER2, 'ZONE TYPES')

         CASE DEFAULT
            CALL SCARC_SHUTDOWN(NSCARC_ERROR_EXCHANGE_RECV, SCARC_NONE, TYPE_EXCHANGE)

      END SELECT SELECT_EXCHANGE_TYPE

   ENDDO RECEIVE_OMESHES_LOOP
ENDDO RECEIVE_MESHES_LOOP


  
! ---------- Pack data for requested exchange type in corresponding SEND-buffer
  
TNOW = CURRENT_TIME()

SEND_PACK_MESHES_LOOP: DO NM = LOWER_MESH_INDEX, UPPER_MESH_INDEX

   CALL SCARC_POINT_TO_GRID (NM, NL)                                   ! Sets grid pointer G

   SEND_PACK_OMESHES_LOOP: DO NOM = 1, NMESHES

      IF (.NOT. ARE_NEIGHBORS(NM, NOM)) CYCLE SEND_PACK_OMESHES_LOOP
      CALL SCARC_POINT_TO_OTHER_GRID(NM, NOM, NL)

      SNODE = PROCESS(NOM)
      RNODE = PROCESS(NM)

      SEND_PACK_OMESHES_SELECT: SELECT CASE (NTYPE)

         CASE (NSCARC_EXCHANGE_AUXILIARY)
            CALL SCARC_PACK_AUXILIARY(NL)
            CALL SCARC_SEND_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER2, 'AUXILIARY')

         CASE (NSCARC_EXCHANGE_BASIC_SIZES)
            CALL SCARC_PACK_BASIC_SIZES
            CALL SCARC_SEND_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_BASIC, 'BASIC SIZES')

         CASE (NSCARC_EXCHANGE_CELL_NEIGHBORS)
            CALL SCARC_PACK_CELL_NEIGHBORS (NL)
            CALL SCARC_SEND_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_LAYER4, 'CELL NEIGHBORS')

         CASE (NSCARC_EXCHANGE_CELL_NUMBERS)
            CALL SCARC_PACK_CELL_NUMBERS
            CALL SCARC_SEND_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'CELL NUMBERS')

         CASE (NSCARC_EXCHANGE_CELL_SIZES)
            CALL SCARC_PACK_CELL_SIZES
            CALL SCARC_SEND_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_BASIC, 'CELL SIZES')

         CASE (NSCARC_EXCHANGE_NULLSPACE)
            CALL SCARC_PACK_NULLSPACE(NL)
            CALL SCARC_SEND_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER2, 'NULLSPACE')

         CASE (NSCARC_EXCHANGE_MATRIX_SIZES)
            CALL SCARC_PACK_MATRIX_SIZES(NL)
            CALL SCARC_SEND_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_BASIC, 'POISSON SIZES')

         CASE (NSCARC_EXCHANGE_MATRIX_DIAGS)
            CALL SCARC_PACK_MATRIX_DIAGS(NSCARC_MATRIX_POISSON)
            CALL SCARC_SEND_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'POISSON DIAGS')

         CASE (NSCARC_EXCHANGE_MATRIX_COLS)
            CALL SCARC_PACK_MATRIX_COLS(NPARAM)
            CALL SCARC_SEND_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_FULL, 'POISSON COLS')

         CASE (NSCARC_EXCHANGE_MATRIX_COLSG)
            CALL SCARC_PACK_MATRIX_COLSG(NPARAM)
            CALL SCARC_SEND_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_FULL, 'POISSON COLSG')

         CASE (NSCARC_EXCHANGE_MATRIX_VALS)
            CALL SCARC_PACK_MATRIX_VALS(NPARAM, NL)
            CALL SCARC_SEND_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_FULL, 'POISSON VALS')

         CASE (NSCARC_EXCHANGE_PRESSURE)
            CALL SCARC_PACK_PRESSURE(NM)
            CALL SCARC_SEND_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'PRESSURE')

         CASE (NSCARC_EXCHANGE_MGM_TRUE)
            CALL SCARC_PACK_MGM_TRUE(NM)
            CALL SCARC_SEND_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER2, 'MGM_TRUE')

         CASE (NSCARC_EXCHANGE_MGM_MEAN)
            CALL SCARC_PACK_MGM_MEAN(NM)
            CALL SCARC_SEND_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'MGM_MEAN')

         CASE (NSCARC_EXCHANGE_MGM_VELO)
            CALL SCARC_PACK_MGM_VELO(NM)
            CALL SCARC_SEND_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'MGM_VELO')

         CASE (NSCARC_EXCHANGE_LAYER2_NUMS)
            CALL SCARC_PACK_LAYER2_NUMS
            CALL SCARC_SEND_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'LAYER2_NUMS')

         CASE (NSCARC_EXCHANGE_LAYER2_VALS)
            CALL SCARC_PACK_LAYER2_VALS
            CALL SCARC_SEND_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'LAYER2_VALS')

         CASE (NSCARC_EXCHANGE_VECTOR_MEAN)
            CALL SCARC_PACK_VECTOR_MEAN(NM, NL, NPARAM)
            CALL SCARC_SEND_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER2, 'VECTOR MEAN')

         CASE (NSCARC_EXCHANGE_VECTOR_PLAIN)
            CALL SCARC_PACK_VECTOR_PLAIN(NM, NL, NPARAM)
            CALL SCARC_SEND_MESSAGE_REAL (NM, NOM, NL, NSCARC_BUFFER_LAYER1, 'VECTOR PLAIN')

         CASE (NSCARC_EXCHANGE_ZONE_NEIGHBORS)
            CALL SCARC_PACK_ZONE_NEIGHBORS(NL)
            CALL SCARC_SEND_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_LAYER4, 'ZONE NEIGHBORS')

         CASE (NSCARC_EXCHANGE_ZONE_TYPES)
            CALL SCARC_PACK_ZONE_TYPES
            CALL SCARC_SEND_MESSAGE_INT (NM, NOM, NL, NSCARC_BUFFER_LAYER2, 'ZONE TYPES')

         CASE DEFAULT
            CALL SCARC_SHUTDOWN(NSCARC_ERROR_EXCHANGE_SEND, SCARC_NONE, TYPE_EXCHANGE)

      END SELECT SEND_PACK_OMESHES_SELECT
   ENDDO SEND_PACK_OMESHES_LOOP
ENDDO SEND_PACK_MESHES_LOOP

CPU(MYID)%BUFFER_PACKING = CPU(MYID)%BUFFER_PACKING   + CURRENT_TIME() - TNOW


 
! ---------- Wait for all meshes to have sent and received their data
 
IF (N_MPI_PROCESSES > 1 .AND. N_REQ /= 0) CALL MPI_WAITALL(N_REQ,REQ(1:N_REQ),MPI_STATUSES_IGNORE,IERROR)


 
! ---------- Unpack received data from corresponding RECEIVE-buffers
 
TNOW = CURRENT_TIME()
SEND_UNPACK_MESHES_LOOP: DO NM = LOWER_MESH_INDEX, UPPER_MESH_INDEX

   CALL SCARC_POINT_TO_GRID (NM, NL)                                   ! Sets grid pointer G

   SEND_UNPACK_OMESHES_LOOP: DO NOM = 1, NMESHES

      SNODE  = PROCESS(NM)
      RNODE  = PROCESS(NOM)

      IF (.NOT. ARE_NEIGHBORS(NM, NOM)) CYCLE SEND_UNPACK_OMESHES_LOOP
      CALL SCARC_POINT_TO_OTHER_GRID(NM, NOM, NL)

      SEND_UNPACK_OMESHES_SELECT: SELECT CASE (NTYPE)

         CASE (NSCARC_EXCHANGE_BASIC_SIZES)
            CALL SCARC_UNPACK_BASIC_SIZES (NM, NOM)

         CASE (NSCARC_EXCHANGE_CELL_NEIGHBORS)
            CALL SCARC_UNPACK_CELL_NEIGHBORS (NM, NOM, NL)

         CASE (NSCARC_EXCHANGE_CELL_NUMBERS)
            CALL SCARC_UNPACK_CELL_NUMBERS (NM, NOM)

         CASE (NSCARC_EXCHANGE_CELL_SIZES)
            CALL SCARC_UNPACK_CELL_SIZES(NM, NOM)

         CASE (NSCARC_EXCHANGE_AUXILIARY)
            CALL SCARC_UNPACK_AUXILIARY (NM, NOM, NL)

         CASE (NSCARC_EXCHANGE_NULLSPACE)
            CALL SCARC_UNPACK_NULLSPACE (NM, NOM, NL)

         CASE (NSCARC_EXCHANGE_MATRIX_SIZES)
            CALL SCARC_UNPACK_MATRIX_SIZES (NM, NOM, NL)

         CASE (NSCARC_EXCHANGE_MATRIX_DIAGS)
            CALL SCARC_UNPACK_MATRIX_DIAGS (NM, NOM)

         CASE (NSCARC_EXCHANGE_MATRIX_COLS)
            CALL SCARC_UNPACK_MATRIX_COLS (NM, NOM, NPARAM)

         CASE (NSCARC_EXCHANGE_MATRIX_COLSG)
            CALL SCARC_UNPACK_MATRIX_COLSG (NM, NOM, NPARAM)

         CASE (NSCARC_EXCHANGE_MATRIX_VALS)
            CALL SCARC_UNPACK_MATRIX_VALS (NM, NOM, NL, NPARAM)

         CASE (NSCARC_EXCHANGE_PRESSURE)
            CALL SCARC_UNPACK_PRESSURE (NM, NOM)

         CASE (NSCARC_EXCHANGE_MGM_TRUE)
            CALL SCARC_UNPACK_MGM_TRUE (NM, NOM)

         CASE (NSCARC_EXCHANGE_MGM_MEAN)
            CALL SCARC_UNPACK_MGM_MEAN (NM, NOM)

         CASE (NSCARC_EXCHANGE_MGM_VELO)
            CALL SCARC_UNPACK_MGM_VELO (NM, NOM)

         CASE (NSCARC_EXCHANGE_LAYER2_NUMS)
            CALL SCARC_UNPACK_LAYER2_NUMS (NM, NOM)

         CASE (NSCARC_EXCHANGE_LAYER2_VALS)
            CALL SCARC_UNPACK_LAYER2_VALS (NM, NOM)

         CASE (NSCARC_EXCHANGE_VECTOR_MEAN)
            CALL SCARC_UNPACK_VECTOR_MEAN (NM, NOM, NL, NPARAM)

         CASE (NSCARC_EXCHANGE_VECTOR_PLAIN)
            CALL SCARC_UNPACK_VECTOR_PLAIN (NM, NOM, NL, NPARAM)

         CASE (NSCARC_EXCHANGE_ZONE_NEIGHBORS)
            CALL SCARC_UNPACK_ZONE_NEIGHBORS (NM, NOM, NL)

         CASE (NSCARC_EXCHANGE_ZONE_TYPES)
            CALL SCARC_UNPACK_ZONE_TYPES (NM, NOM)

         CASE DEFAULT
            CALL SCARC_SHUTDOWN(NSCARC_ERROR_EXCHANGE_SEND, SCARC_NONE, TYPE_EXCHANGE)

      END SELECT SEND_UNPACK_OMESHES_SELECT
   ENDDO SEND_UNPACK_OMESHES_LOOP
ENDDO SEND_UNPACK_MESHES_LOOP

CPU(MYID)%BUFFER_UNPACKING = CPU(MYID)%BUFFER_UNPACKING   + CURRENT_TIME() - TNOW

END SUBROUTINE SCARC_EXCHANGE


! ------------------------------------------------------------------------------------------------
!> \brief Receive data of type integer
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_RECV_MESSAGE_INT(NM, NOM, NL, NTYPE, CTEXT)
USE SCARC_POINTERS, ONLY: OS, OG
INTEGER, INTENT(IN) :: NM, NOM, NL, NTYPE
CHARACTER(*), INTENT(IN) :: CTEXT
!INTEGER,  DIMENSION(:), POINTER :: RECV_BUFFER_INT
INTEGER,  POINTER :: RECV_BUFFER_INT
INTEGER :: NLEN
#ifndef WITH_SCARC_VERBOSE2
INTEGER :: IDUMMY
CHARACTER(40) :: CDUMMY
#endif

IF (RNODE == SNODE) RETURN
N_REQ = N_REQ+1

SELECT CASE(NTYPE)
   CASE (NSCARC_BUFFER_BASIC)
      RECV_BUFFER_INT => OS%RECV_BUFFER_INT0(1);  NLEN = NSCARC_MAX_BUFFER0
   CASE (NSCARC_BUFFER_FULL)
      RECV_BUFFER_INT => OS%RECV_BUFFER_INT(1) ;  NLEN = OG%NLEN_BUFFER_FULL
   CASE (NSCARC_BUFFER_LAYER1)
      RECV_BUFFER_INT => OS%RECV_BUFFER_INT(1) ;  NLEN = OG%NLEN_BUFFER_LAYER1
   CASE (NSCARC_BUFFER_LAYER2)
      RECV_BUFFER_INT => OS%RECV_BUFFER_INT(1) ;  NLEN = OG%NLEN_BUFFER_LAYER2
   CASE (NSCARC_BUFFER_LAYER4)
      RECV_BUFFER_INT => OS%RECV_BUFFER_INT(1) ;  NLEN = OG%NLEN_BUFFER_LAYER4
   CASE (NSCARC_BUFFER_STENCIL)
      RECV_BUFFER_INT => OS%RECV_BUFFER_INT(1) ;  NLEN = OG%NLEN_BUFFER_STENCIL
END SELECT

#ifdef WITH_SCARC_VERBOSE2
WRITE(MSG%LU_VERBOSE,1000, ADVANCE = 'NO') CTEXT, NLEN, NM, NOM, NL
#else
IDUMMY = NM; IDUMMY = NOM; IDUMMY = NL                ! prevent compilation warning in case that VERBOSE flag is not set
CDUMMY = CTEXT
#endif

RECV_BUFFER_INT = NSCARC_HUGE_INT
CALL MPI_IRECV(RECV_BUFFER_INT, NLEN, MPI_INTEGER, SNODE, TAG, MPI_COMM_WORLD, REQ(N_REQ),IERROR)

#ifdef WITH_SCARC_VERBOSE2
WRITE(MSG%LU_VERBOSE,*) ' ...  done'
1000 FORMAT('SCARC_RECV_MESSAGE_INT  : Receiving ',A20, ' in length =', I8,' from ',I8, ' to ', I8, ' on level ', I4)
#endif
END SUBROUTINE SCARC_RECV_MESSAGE_INT

! ------------------------------------------------------------------------------------------------
!> \brief Receive data of type real
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_RECV_MESSAGE_REAL(NM, NOM, NL, NTYPE, CTEXT)
USE SCARC_POINTERS, ONLY: OS, OG
INTEGER, INTENT(IN) :: NM, NOM, NL, NTYPE
CHARACTER(*), INTENT(IN) :: CTEXT
!REAL(EB), DIMENSION(:), POINTER :: RECV_BUFFER_REAL
REAL(EB), POINTER :: RECV_BUFFER_REAL
INTEGER :: NLEN
#ifndef WITH_SCARC_VERBOSE2
INTEGER :: IDUMMY
CHARACTER(40) :: CDUMMY
#endif

IF (RNODE == SNODE) RETURN
N_REQ = N_REQ+1


SELECT CASE(NTYPE)
   CASE (NSCARC_BUFFER_BASIC)
      RECV_BUFFER_REAL => OS%RECV_BUFFER_REAL0(1);  NLEN = NSCARC_MAX_BUFFER0
   CASE (NSCARC_BUFFER_FULL)
      RECV_BUFFER_REAL => OS%RECV_BUFFER_REAL(1) ;  NLEN = OG%NLEN_BUFFER_FULL
   CASE (NSCARC_BUFFER_LAYER1)
      RECV_BUFFER_REAL => OS%RECV_BUFFER_REAL(1) ;  NLEN = OG%NLEN_BUFFER_LAYER1
   CASE (NSCARC_BUFFER_LAYER2)
      RECV_BUFFER_REAL => OS%RECV_BUFFER_REAL(1) ;  NLEN = OG%NLEN_BUFFER_LAYER2
   CASE (NSCARC_BUFFER_LAYER4)
      RECV_BUFFER_REAL => OS%RECV_BUFFER_REAL(1) ;  NLEN = OG%NLEN_BUFFER_LAYER4
   CASE (NSCARC_BUFFER_STENCIL)
      RECV_BUFFER_REAL => OS%RECV_BUFFER_REAL(1) ;  NLEN = OG%NLEN_BUFFER_STENCIL
END SELECT

#ifdef WITH_SCARC_VERBOSE2
WRITE(MSG%LU_VERBOSE,1000, ADVANCE = 'NO') CTEXT, NLEN, NM, NOM, NL
#else
IDUMMY = NM; IDUMMY = NOM; IDUMMY = NL                ! prevent compilation warning in case that VERBOSE flag is not set
CDUMMY = CTEXT
#endif

RECV_BUFFER_REAL = NSCARC_INIT_UNDEF
CALL MPI_IRECV(RECV_BUFFER_REAL, NLEN, MPI_DOUBLE_PRECISION, SNODE, TAG, MPI_COMM_WORLD, REQ(N_REQ), IERROR)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,*) 'RECV_MESSAGE_REAL: NM, NOM, NL, NTYPE:', NM, NOM, NL, NTYPE, OS%RECV_BUFFER_REAL(1)
#endif

#ifdef WITH_SCARC_VERBOSE2
WRITE(MSG%LU_VERBOSE,*) ' ...  done'
1000 FORMAT('SCARC_RECV_MESSAGE_REAL : Receiving ',A20, ' in length =', I8,' from ',I8, ' to ', I8, ' on level ', I4)
#endif
END SUBROUTINE SCARC_RECV_MESSAGE_REAL


! ------------------------------------------------------------------------------------------------
!> \brief Send data of integer type
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_SEND_MESSAGE_INT(NM, NOM, NL, NTYPE, CTEXT)
USE SCARC_POINTERS, ONLY: OS, OG
CHARACTER(*), INTENT(IN) :: CTEXT
INTEGER, INTENT(IN) :: NM, NOM, NL, NTYPE
!INTEGER,  DIMENSION(:), POINTER :: SEND_BUFFER_INT
INTEGER,  POINTER :: SEND_BUFFER_INT
INTEGER :: NLEN
#ifndef WITH_SCARC_VERBOSE2
INTEGER :: IDUMMY
CHARACTER(40) :: CDUMMY
#endif

IF (RNODE == SNODE) RETURN
N_REQ = N_REQ+1

SELECT CASE(NTYPE)
   CASE (NSCARC_BUFFER_BASIC)
      SEND_BUFFER_INT => OS%SEND_BUFFER_INT0(1);  NLEN = NSCARC_MAX_BUFFER0
   CASE (NSCARC_BUFFER_FULL)
      SEND_BUFFER_INT => OS%SEND_BUFFER_INT(1) ;  NLEN = OG%NLEN_BUFFER_FULL
   CASE (NSCARC_BUFFER_LAYER1)
      SEND_BUFFER_INT => OS%SEND_BUFFER_INT(1) ;  NLEN = OG%NLEN_BUFFER_LAYER1
   CASE (NSCARC_BUFFER_LAYER2)
      SEND_BUFFER_INT => OS%SEND_BUFFER_INT(1) ;  NLEN = OG%NLEN_BUFFER_LAYER2
   CASE (NSCARC_BUFFER_LAYER4)
      SEND_BUFFER_INT => OS%SEND_BUFFER_INT(1) ;  NLEN = OG%NLEN_BUFFER_LAYER4
   CASE (NSCARC_BUFFER_STENCIL)
      SEND_BUFFER_INT => OS%SEND_BUFFER_INT(1) ;  NLEN = OG%NLEN_BUFFER_STENCIL
END SELECT

#ifdef WITH_SCARC_VERBOSE2
WRITE(MSG%LU_VERBOSE,1000, ADVANCE = 'NO') CTEXT, NLEN, NM, NOM, NL
#else
IDUMMY = NM; IDUMMY = NOM; IDUMMY = NL                ! prevent compilation warning in case that VERBOSE flag is not set
CDUMMY = CTEXT
#endif

CALL MPI_ISEND(SEND_BUFFER_INT, NLEN, MPI_INTEGER, SNODE, TAG, MPI_COMM_WORLD, REQ(N_REQ),IERROR)

#ifdef WITH_SCARC_VERBOSE2
WRITE(MSG%LU_VERBOSE,*) ' ...  done'
1000 FORMAT('SCARC_SEND_MESSAGE_INT  : Sending   ',A20, ' in length =', I8,' from ',I8, ' to ', I8, ' on level ', I4)
#endif
END SUBROUTINE SCARC_SEND_MESSAGE_INT


! ------------------------------------------------------------------------------------------------
!> \brief Send data of real type
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_SEND_MESSAGE_REAL(NM, NOM, NL, NTYPE, CTEXT)
USE SCARC_POINTERS, ONLY: OS, OG
CHARACTER(*), INTENT(IN) :: CTEXT
INTEGER, INTENT(IN) :: NM, NOM, NL, NTYPE
!REAL(EB), DIMENSION(:), POINTER :: SEND_BUFFER_REAL
REAL(EB), POINTER :: SEND_BUFFER_REAL
INTEGER :: NLEN
#ifndef WITH_SCARC_VERBOSE2
INTEGER :: IDUMMY
CHARACTER(40) :: CDUMMY
#endif

IF (RNODE == SNODE) RETURN
N_REQ = N_REQ+1


SELECT CASE(NTYPE)
   CASE (NSCARC_BUFFER_BASIC)
      SEND_BUFFER_REAL => OS%SEND_BUFFER_REAL0(1);  NLEN = NSCARC_MAX_BUFFER0
   CASE (NSCARC_BUFFER_FULL)
      SEND_BUFFER_REAL => OS%SEND_BUFFER_REAL(1) ;  NLEN = OG%NLEN_BUFFER_FULL
   CASE (NSCARC_BUFFER_LAYER1)
      SEND_BUFFER_REAL => OS%SEND_BUFFER_REAL(1) ;  NLEN = OG%NLEN_BUFFER_LAYER1
   CASE (NSCARC_BUFFER_LAYER2)
      SEND_BUFFER_REAL => OS%SEND_BUFFER_REAL(1) ;  NLEN = OG%NLEN_BUFFER_LAYER2
   CASE (NSCARC_BUFFER_LAYER4)
      SEND_BUFFER_REAL => OS%SEND_BUFFER_REAL(1) ;  NLEN = OG%NLEN_BUFFER_LAYER4
   CASE (NSCARC_BUFFER_STENCIL)
      SEND_BUFFER_REAL => OS%SEND_BUFFER_REAL(1) ;  NLEN = OG%NLEN_BUFFER_STENCIL
END SELECT


#ifdef WITH_SCARC_VERBOSE2
WRITE(MSG%LU_VERBOSE,1000, ADVANCE = 'NO') CTEXT, NLEN, NM, NOM, NL
#else
IDUMMY = NM; IDUMMY = NOM; IDUMMY = NL                ! prevent compilation warning in case that VERBOSE flag is not set
CDUMMY = CTEXT
#endif

CALL MPI_ISEND(SEND_BUFFER_REAL, NLEN, MPI_DOUBLE_PRECISION, SNODE, TAG, MPI_COMM_WORLD, REQ(N_REQ), IERROR)

#ifdef WITH_SCARC_VERBOSE2
WRITE(MSG%LU_VERBOSE,*) ' ...  done'
1000 FORMAT('SCARC_SEND_MESSAGE_REAL : Sending   ',A20, ' in length =', I8,' from ',I8, ' to ', I8, ' on level ', I4)
#endif
END SUBROUTINE SCARC_SEND_MESSAGE_REAL


! ------------------------------------------------------------------------------------------------
!> \brief Pack numbers of cells which are overlapped by neighbor
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_CELL_NUMBERS
USE SCARC_POINTERS, ONLY: G, OS, OL, OG
INTEGER :: IOR0, ICG, IWG, IXW, IYW, IZW

OS%SEND_BUFFER_INT = NSCARC_HUGE_INT
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'PACK_CELL_NUMBERS: OL%GHOST_FIRSTW(',IOR0,')=', OL%GHOST_FIRSTW
WRITE(MSG%LU_DEBUG,*) 'PACK_CELL_NUMBERS: OL%GHOST_FIRSTE(',IOR0,')=', OL%GHOST_FIRSTE
#endif
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      IWG = OG%ICG_TO_IWG(ICG)
      IXW = G%WALL(IWG)%IXW
      IYW = G%WALL(IWG)%IYW
      IZW = G%WALL(IWG)%IZW
      OS%SEND_BUFFER_INT(ICG) = G%CELL_NUMBER(IXW, IYW, IZW)
   ENDDO
ENDDO
END SUBROUTINE SCARC_PACK_CELL_NUMBERS


! ------------------------------------------------------------------------------------------------
!> \brief Unpack numbers of cells which are overlapped by neighbor
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_CELL_NUMBERS (NM, NOM)
USE SCARC_POINTERS, ONLY: L, G, OL, OG, RECV_BUFFER_INT
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_INT
INTEGER, INTENT(IN) :: NM, NOM
INTEGER :: LL, IOR0, ICG, ICE, IWG, IXG, IYG, IZG

RECV_BUFFER_INT => SCARC_POINT_TO_BUFFER_INT (NM, NOM, 1)
LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      ICE = OG%ICG_TO_ICE(ICG, 1)
      G%ICE_TO_ICN(ICE) = RECV_BUFFER_INT(LL)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'ICE_TO_ICN(',ICE,')=', G%ICE_TO_ICN(ICE), TYPE_GRID
#endif
      IWG = OG%ICG_TO_IWG(ICG)
      IXG = G%WALL(IWG)%IXG
      IYG = G%WALL(IWG)%IYG
      IZG = G%WALL(IWG)%IZG
      IF (RECV_BUFFER_INT(ICG) < 0) THEN
         L%IS_SOLID(IXG, IYG, IZG) = .TRUE.
         G%CELL_NUMBER(IXG, IYG, IZG) = -G%CELL_NUMBER(IXG, IYG, IZG)     ! mark solid cell with negative sign
      ELSE
         L%IS_SOLID(IXG, IYG, IZG) = .FALSE.
      ENDIF
      LL = LL + 1
   ENDDO
ENDDO
END SUBROUTINE SCARC_UNPACK_CELL_NUMBERS


! ------------------------------------------------------------------------------------------------
!> \brief Pack cell width information 
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_CELL_SIZES
USE SCARC_POINTERS, ONLY: L, OS

OS%SEND_BUFFER_REAL0(1) = L%DXL(0)
OS%SEND_BUFFER_REAL0(2) = L%DXL(L%NX)
OS%SEND_BUFFER_REAL0(3) = L%DYL(0)
OS%SEND_BUFFER_REAL0(4) = L%DYL(L%NY)
OS%SEND_BUFFER_REAL0(5) = L%DZL(0)
OS%SEND_BUFFER_REAL0(6) = L%DZL(L%NZ)

END SUBROUTINE SCARC_PACK_CELL_SIZES


! ------------------------------------------------------------------------------------------------
!> \brief Unpack cell width information 
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_CELL_SIZES (NM, NOM)
USE SCARC_POINTERS, ONLY: L, OL, RECV_BUFFER_REAL           
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_REAL
INTEGER, INTENT(IN) :: NM, NOM

RECV_BUFFER_REAL => SCARC_POINT_TO_BUFFER_REAL (NM, NOM, 0)

IF (OL%GHOST_LASTW(-1) /= 0) L%DXL(0)    = 0.5_EB*(RECV_BUFFER_REAL(1) + L%DXL(0))
IF (OL%GHOST_LASTW( 1) /= 0) L%DXL(L%NX) = 0.5_EB*(RECV_BUFFER_REAL(2) + L%DXL(L%NX))
IF (OL%GHOST_LASTW(-2) /= 0) L%DYL(0)    = 0.5_EB*(RECV_BUFFER_REAL(3) + L%DYL(0))
IF (OL%GHOST_LASTW( 2) /= 0) L%DYL(L%NY) = 0.5_EB*(RECV_BUFFER_REAL(4) + L%DYL(L%NY))
IF (OL%GHOST_LASTW(-3) /= 0) L%DZL(0)    = 0.5_EB*(RECV_BUFFER_REAL(5) + L%DZL(0))
IF (OL%GHOST_LASTW( 3) /= 0) L%DZL(L%NZ) = 0.5_EB*(RECV_BUFFER_REAL(6) + L%DZL(L%NZ))

END SUBROUTINE SCARC_UNPACK_CELL_SIZES


! ------------------------------------------------------------------------------------------------
!> \brief Pack initial exchange sizes along interfaces
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_BASIC_SIZES
USE SCARC_POINTERS, ONLY: OS, OG

OS%SEND_BUFFER_INT0(1)=OG%NCG
OS%SEND_BUFFER_INT0(2)=OG%NZG

END SUBROUTINE SCARC_PACK_BASIC_SIZES


! ------------------------------------------------------------------------------------------------
!> \brief Unpack initial exchange sizes along interfaces
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_BASIC_SIZES (NM, NOM)
USE SCARC_POINTERS, ONLY: OG, RECV_BUFFER_INT
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_INT
INTEGER, INTENT(IN) :: NM, NOM

RECV_BUFFER_INT => SCARC_POINT_TO_BUFFER_INT (NM, NOM, 0)

OG%NCG = RECV_BUFFER_INT(1)
OG%NZG = RECV_BUFFER_INT(2)

END SUBROUTINE SCARC_UNPACK_BASIC_SIZES


! ------------------------------------------------------------------------------------------------
!> \brief Pack overlapping parts of specified pressure vector (predictor/corrector)
! Note: Vector VC is numbered via I, J, K values
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_PRESSURE(NM)
USE SCARC_POINTERS, ONLY: G, OS, OL, OG, OS
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_HVECTOR
INTEGER, INTENT(IN) :: NM
REAL(EB), DIMENSION(:,:,:), POINTER :: VC
INTEGER :: IOR0, ICG, IWG

IF (PREDICTOR) THEN
   VC => SCARC_POINT_TO_HVECTOR (NM, NSCARC_VECTOR_H)
ELSE
   VC => SCARC_POINT_TO_HVECTOR (NM, NSCARC_VECTOR_HS)
ENDIF
OS%SEND_BUFFER_REAL = NSCARC_HUGE_REAL_EB
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      IWG = OG%ICG_TO_IWG(ICG)
      OS%SEND_BUFFER_REAL(ICG) = VC(G%WALL(IWG)%IXW, G%WALL(IWG)%IYW, G%WALL(IWG)%IZW)
   ENDDO
ENDDO
END SUBROUTINE SCARC_PACK_PRESSURE


! ------------------------------------------------------------------------------------------------
!> \brief Unpack overlapping parts of specified pressure vector (predictor/corrector)
! Note: Vector VC is numbered via I, J, K values
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_PRESSURE(NM, NOM)
USE SCARC_POINTERS, ONLY: G, OL, OG, RECV_BUFFER_REAL
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_REAL, SCARC_POINT_TO_HVECTOR
INTEGER, INTENT(IN) :: NM, NOM
REAL(EB), DIMENSION(:,:,:), POINTER :: VC
INTEGER :: LL, IOR0, IWG, IXG, IYG, IZG, ICG

RECV_BUFFER_REAL => SCARC_POINT_TO_BUFFER_REAL (NM, NOM, 1)
IF (PREDICTOR) THEN
   VC => SCARC_POINT_TO_HVECTOR (NM, NSCARC_VECTOR_H)
ELSE
   VC => SCARC_POINT_TO_HVECTOR (NM, NSCARC_VECTOR_HS)
ENDIF
LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   UNPACK_PRESSURE: DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      IWG = OG%ICG_TO_IWG(ICG)
      IXG=G%WALL(IWG)%IXG
      IYG=G%WALL(IWG)%IYG
      IZG=G%WALL(IWG)%IZG
      VC(IXG, IYG, IZG) = RECV_BUFFER_REAL(LL)
      LL = LL + 1
   ENDDO UNPACK_PRESSURE
ENDDO
END SUBROUTINE SCARC_UNPACK_PRESSURE


! ------------------------------------------------------------------------------------------------
!> \brief Pack overlapping parts of specified vector VC (numbered via IC values)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_MGM_TRUE(NM)
USE SCARC_POINTERS, ONLY: G, OL, OG, OS
INTEGER, INTENT(IN) :: NM
REAL(EB), DIMENSION(:,:,:), POINTER :: H2
INTEGER :: IOR0, ICG, ICW, IWG, IXW, IYW, IZW, LL

H2 => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%H2
OS%SEND_BUFFER_REAL = NSCARC_ZERO_REAL_EB

LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      ICW = OG%ICG_TO_ICW(ICG, 1)
      IF (ICW < 0) CYCLE                                  ! skip solid cells
      IWG = OG%ICG_TO_IWG(ICG)
      IXW=G%WALL(IWG)%IXW
      IYW=G%WALL(IWG)%IYW
      IZW=G%WALL(IWG)%IZW
      OS%SEND_BUFFER_REAL(LL) = H2(IXW, IYW, IZW)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,*) 'PACK_MGM_TRUE: IOR0, ICG, ICW, IXW, IYW, IZW, REAL(ICG): ', &
                       IOR0, ICG, ICW, IXW, IYW, IZW, OS%SEND_BUFFER_REAL(LL)
#endif
      SELECT CASE (IOR0)
         CASE (1)
            OS%SEND_BUFFER_REAL(LL+1) = H2(IXW+1, IYW, IZW)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,*) 'PACK_MGM_TRUE: IOR0, ICG, ICW, IXW, IYW, IZW, REAL(ICG): ', &
                       IOR0, ICG, ICW, IXW+1, IYW, IZW, OS%SEND_BUFFER_REAL(LL+1)
#endif
         CASE (-1)
            OS%SEND_BUFFER_REAL(LL+1) = H2(IXW-1, IYW, IZW)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,*) 'PACK_MGM_TRUE: IOR0, ICG, ICW, IXW, IYW, IZW, REAL(ICG): ', &
                       IOR0, ICG, ICW, IXW-1, IYW, IZW, OS%SEND_BUFFER_REAL(LL+1)
#endif
         CASE ( 2)
            OS%SEND_BUFFER_REAL(LL+1) = H2(IXW, IYW+1, IZW)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,*) 'PACK_MGM_TRUE: IOR0, ICG, ICW, IXW, IYW, IZW, REAL(ICG): ', &
                       IOR0, ICG, ICW, IXW, IYW+1, IZW, OS%SEND_BUFFER_REAL(LL+1)
#endif
         CASE (-2)
            OS%SEND_BUFFER_REAL(LL+1) = H2(IXW, IYW-1, IZW)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,*) 'PACK_MGM_TRUE: IOR0, ICG, ICW, IXW, IYW, IZW, REAL(ICG): ', &
                       IOR0, ICG, ICW, IXW, IYW-1, IZW, OS%SEND_BUFFER_REAL(LL+1)
#endif
         CASE ( 3)
            OS%SEND_BUFFER_REAL(LL+1) = H2(IXW, IYW, IZW+1)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,*) 'PACK_MGM_TRUE: IOR0, ICG, ICW, IXW, IYW, IZW, REAL(ICG): ', &
                       IOR0, ICG, ICW, IXW, IYW, IZW+1, OS%SEND_BUFFER_REAL(LL+1)
#endif
         CASE (-3)
            OS%SEND_BUFFER_REAL(LL+1) = H2(IXW, IYW, IZW-1)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,*) 'PACK_MGM_TRUE: IOR0, ICG, ICW, IXW, IYW, IZW, REAL(ICG): ', &
                       IOR0, ICG, ICW, IXW, IYW, IZW-1, OS%SEND_BUFFER_REAL(LL+1)
#endif
      END SELECT
      LL = LL + 2
   ENDDO
ENDDO

#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'PACK: Sizes SEND_BUFFER_REAL, VC=', SIZE(OS%SEND_BUFFER_REAL), SIZE(H2)
WRITE(MSG%LU_DEBUG,'(8E14.6)') OS%SEND_BUFFER_REAL(1:16)
#endif

END SUBROUTINE SCARC_PACK_MGM_TRUE

! ------------------------------------------------------------------------------------------------
!> \brief Unpack overlapping parts of specified pressure vector (predictor/corrector)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_MGM_TRUE(NM, NOM)
USE SCARC_POINTERS, ONLY: OL, OG, RECV_BUFFER_REAL, OH1, OH2
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_REAL
INTEGER, INTENT(IN) :: NM, NOM
INTEGER :: LL, IOR0, ICG, IWG

RECV_BUFFER_REAL => SCARC_POINT_TO_BUFFER_REAL (NM, NOM, 1)
OH1 => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%OH1
OH2 => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%OH2
LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   UNPACK_MGM_TRUE: DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      IWG = OG%ICG_TO_IWG(ICG)
      OH1(IWG) = RECV_BUFFER_REAL(LL)
      OH2(IWG) = RECV_BUFFER_REAL(LL+1)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 4I4, 2E14.6)') 'UNPACK_MGM_TRUE: NM, NOM, ICG, IWG, OH1, OH2:', NM, NOM, ICG, IWG, OH1(IWG), OH2(IWG)
#endif
      LL = LL + 2
   ENDDO UNPACK_MGM_TRUE
ENDDO
END SUBROUTINE SCARC_UNPACK_MGM_TRUE


! ------------------------------------------------------------------------------------------------
!> \brief Pack overlapping parts of specified vector VC (numbered via IC values)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_MGM_MEAN(NM)
USE SCARC_POINTERS, ONLY: G, OL, OG, OS, H2
INTEGER, INTENT(IN) :: NM
INTEGER :: IOR0, ICG, ICW, IWG, IXW, IYW, IZW

H2 => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%H2
OS%SEND_BUFFER_REAL = NSCARC_ZERO_REAL_EB

DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      ICW = OG%ICG_TO_ICW(ICG, 1)
      IF (ICW < 0) CYCLE                                  ! skip solid cells
      IWG = OG%ICG_TO_IWG(ICG)
      IXW=G%WALL(IWG)%IXW
      IYW=G%WALL(IWG)%IYW
      IZW=G%WALL(IWG)%IZW
      OS%SEND_BUFFER_REAL(ICG) = H2(IXW, IYW, IZW)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,*) 'PACK_MGM_MEAN: IOR0, ICG, ICW, IXW, IYW, IZW, REAL(ICG): ', IOR0, ICG, ICW, IXW, IYW, IZW, H2(IXW, IYW, IZW)
#endif
   ENDDO
ENDDO

#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,*) 'PACK: Sizes SEND_BUFFER_REAL, VC=', SIZE(OS%SEND_BUFFER_REAL), SIZE(H2)
WRITE(MSG%LU_DEBUG,'(8E14.6)') OS%SEND_BUFFER_REAL(1:16)
#endif

END SUBROUTINE SCARC_PACK_MGM_MEAN


! ------------------------------------------------------------------------------------------------
!> \brief Unpack overlapping parts of specified vector VC (numbered via IC values)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_MGM_MEAN(NM, NOM)
USE SCARC_POINTERS, ONLY: OL, OG, OH1, OH1, RECV_BUFFER_REAL
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_REAL
INTEGER, INTENT(IN) :: NM, NOM
INTEGER :: IOR0, ICG, IWG, LL

OH1 => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%OH1
RECV_BUFFER_REAL => SCARC_POINT_TO_BUFFER_REAL (NM, NOM, 1)

#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,*) 'UNPACK: Sizes RECV_BUFFER_REAL, VC=', SIZE(RECV_BUFFER_REAL), SIZE(OH1)
WRITE(MSG%LU_DEBUG,'(8E14.6)') RECV_BUFFER_REAL(1:16)
WRITE(MSG%LU_DEBUG,*) 'UNPACK: MGM2=', NM, NOM
#endif

LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   UNPACK_MGM_MEAN: DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      IWG = OG%ICG_TO_IWG(ICG)
      OH1(IWG) = RECV_BUFFER_REAL(LL)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 4I4, E14.6)') 'UNPACK_MGM_MEAN: NM, NOM, ICG, IWG, OH1:', NM, NOM, ICG, IWG, OH1(IWG)
#endif
      LL = LL + 1
   ENDDO UNPACK_MGM_MEAN
ENDDO

END SUBROUTINE SCARC_UNPACK_MGM_MEAN


! ------------------------------------------------------------------------------------------------
!> \brief Pack overlapping parts of specified pressure vector (predictor/corrector)
! Note: Vector VC is numbered via I, J, K values
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_MGM_VELO(NM)
USE SCARC_POINTERS, ONLY: G, OL, OG, OS, UU, VV, WW
INTEGER, INTENT(IN) :: NM
INTEGER :: IOR0, ICG, IWG, IXW, IYW, IZW, LL

OS%SEND_BUFFER_REAL = NSCARC_HUGE_REAL_EB

UU => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%U3
VV => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%V3
WW => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%W3

LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      IWG = OG%ICG_TO_IWG(ICG)
      IXW=G%WALL(IWG)%IXW
      IYW=G%WALL(IWG)%IYW
      IZW=G%WALL(IWG)%IZW
      SELECT CASE (IOR0)
         CASE ( 1)
            OS%SEND_BUFFER_REAL(LL) = UU(IXW-1, IYW, IZW) 
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 8I4, 1E14.6)') 'PACK_MGM_VELO: NM, IOR0, ICG, IWG, IXW, IYW, IZW, :', &
                       NM, IOR0, ICG, IWG, IWG, IXW, IYW, IZW, UU(IXW-1, IYW, IZW)
#endif
         CASE (-1)
            OS%SEND_BUFFER_REAL(LL) = UU(IXW, IYW, IZW) 
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 8I4, 1E14.6)') 'PACK_MGM_VELO: NM, IOR0, ICG, IWG, IXW, IYW, IZW, :', &
                       NM, IOR0, ICG, IWG, IWG, IXW, IYW, IZW, UU(IXW, IYW, IZW)
#endif
         CASE ( 2)
            OS%SEND_BUFFER_REAL(LL) = VV(IXW, IYW-1, IZW) 
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 8I4, 1E14.6)') 'PACK_MGM_VELO: NM, IOR0, ICG, IWG, IXW, IYW, IZW, :', &
                       NM, IOR0, ICG, IWG, IWG, IXW, IYW, IZW, VV(IXW, IYW-1, IZW)
#endif
         CASE (-2)
            OS%SEND_BUFFER_REAL(LL) = VV(IXW, IYW, IZW) 
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 8I4, 1E14.6)') 'PACK_MGM_VELO: NM, IOR0, ICG, IWG, IXW, IYW, IZW, :', &
                       NM, IOR0, ICG, IWG, IWG, IXW, IYW, IZW, VV(IXW, IYW, IZW)
#endif
         CASE ( 3)
            OS%SEND_BUFFER_REAL(LL) = WW(IXW, IYW, IZW-1) 
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 8I4, 1E14.6)') 'PACK_MGM_VELO: NM, IOR0, ICG, IWG, IXW, IYW, IZW, :', &
                       NM, IOR0, ICG, IWG, IWG, IXW, IYW, IZW, WW(IXW, IYW, IZW-1)
#endif
         CASE (-3)
            OS%SEND_BUFFER_REAL(LL) = WW(IXW, IYW, IZW) 
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 8I4, 1E14.6)') 'PACK_MGM_VELO: NM, IOR0, ICG, IWG, IXW, IYW, IZW, :', &
                       NM, IOR0, ICG, IWG, IWG, IXW, IYW, IZW, WW(IXW, IYW, IZW)
#endif
      END SELECT
      LL = LL + 1
   ENDDO
ENDDO
END SUBROUTINE SCARC_PACK_MGM_VELO

! ------------------------------------------------------------------------------------------------
!> \brief Pack overlapping parts of specified pressure vector (predictor/corrector)
! Note: Vector VC is numbered via I, J, K values
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_MGM_VELO2(NM)
USE SCARC_POINTERS, ONLY: G, OL, OG, OS, UU, VV, WW
INTEGER, INTENT(IN) :: NM
REAL(EB), DIMENSION(:,:,:), POINTER :: H3
INTEGER :: IOR0, ICG, IWG, IXW, IYW, IZW, LL

OS%SEND_BUFFER_REAL = NSCARC_HUGE_REAL_EB

H3 => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%H3
UU => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%U3
VV => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%V3
WW => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%W3

LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      IWG = OG%ICG_TO_IWG(ICG)
      IXW=G%WALL(IWG)%IXW
      IYW=G%WALL(IWG)%IYW
      IZW=G%WALL(IWG)%IZW
      SELECT CASE (IOR0)
         CASE ( 1)
            OS%SEND_BUFFER_REAL(LL)   = H3(IXW, IYW, IZW) - H3(IXW-1, IYW, IZW)
            OS%SEND_BUFFER_REAL(LL+1) = UU(IXW-1, IYW, IZW) 
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 8I4, 3E14.6)') 'PACK_MGM_VELO: NM, IOR0, ICG, IWG, IXW, IYW, IZW, :', &
                       NM, IOR0, ICG, IWG, IWG, IXW, IYW, IZW, H3(IXW, IYW, IZW), H3(IXW-1, IYW, IZW), UU(IXW-1, IYW, IZW)
#endif
         CASE (-1)
            OS%SEND_BUFFER_REAL(LL)   = H3(IXW+1, IYW, IZW) - H3(IXW, IYW, IZW)
            OS%SEND_BUFFER_REAL(LL+1) = UU(IXW, IYW, IZW) 
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 8I4, 3E14.6)') 'PACK_MGM_VELO: NM, IOR0, ICG, IWG, IXW, IYW, IZW, :', &
                       NM, IOR0, ICG, IWG, IWG, IXW, IYW, IZW, H3(IXW+1, IYW, IZW), H3(IXW, IYW, IZW), UU(IXW, IYW, IZW)
#endif
         CASE ( 2)
            OS%SEND_BUFFER_REAL(LL)   = H3(IXW, IYW, IZW) - H3(IXW, IYW-1, IZW)
            OS%SEND_BUFFER_REAL(LL+1) = VV(IXW, IYW-1, IZW) 
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 8I4, 3E14.6)') 'PACK_MGM_VELO: NM, IOR0, ICG, IWG, IXW, IYW, IZW, :', &
                       NM, IOR0, ICG, IWG, IWG, IXW, IYW, IZW, H3(IXW, IYW, IZW), H3(IXW, IYW-1, IZW), VV(IXW, IYW-1, IZW)
#endif
         CASE (-2)
            OS%SEND_BUFFER_REAL(LL)   = H3(IXW, IYW+1, IZW) - H3(IXW, IYW, IZW)
            OS%SEND_BUFFER_REAL(LL+1) = VV(IXW, IYW, IZW) 
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 8I4, 3E14.6)') 'PACK_MGM_VELO: NM, IOR0, ICG, IWG, IXW, IYW, IZW, :', &
                       NM, IOR0, ICG, IWG, IWG, IXW, IYW, IZW, H3(IXW, IYW+1, IZW), H3(IXW, IYW, IZW), VV(IXW, IYW, IZW)
#endif
         CASE ( 3)
            OS%SEND_BUFFER_REAL(LL)   = H3(IXW, IYW, IZW) - H3(IXW, IYW, IZW-1)
            OS%SEND_BUFFER_REAL(LL+1) = WW(IXW, IYW, IZW-1) 
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 8I4, 3E14.6)') 'PACK_MGM_VELO: NM, IOR0, ICG, IWG, IXW, IYW, IZW, :', &
                       NM, IOR0, ICG, IWG, IWG, IXW, IYW, IZW, H3(IXW, IYW, IZW), H3(IXW, IYW, IZW-1), WW(IXW, IYW, IZW-1)
#endif
         CASE (-3)
            OS%SEND_BUFFER_REAL(LL)   = H3(IXW, IYW, IZW+1) - H3(IXW, IYW, IZW)
            OS%SEND_BUFFER_REAL(LL+1) = WW(IXW, IYW, IZW) 
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 8I4, 3E14.6)') 'PACK_MGM_VELO: NM, IOR0, ICG, IWG, IXW, IYW, IZW, :', &
                       NM, IOR0, ICG, IWG, IWG, IXW, IYW, IZW, H3(IXW, IYW, IZW+1), H3(IXW, IYW, IZW), WW(IXW, IYW, IZW)
#endif
      END SELECT
      LL = LL + 2
   ENDDO
ENDDO
END SUBROUTINE SCARC_PACK_MGM_VELO2


! ------------------------------------------------------------------------------------------------
!> \brief Unpack overlapping parts of specified pressure vector (predictor/corrector)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_MGM_VELO(NM, NOM)
USE SCARC_POINTERS, ONLY: OL, OG, RECV_BUFFER_REAL
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_REAL
INTEGER, INTENT(IN) :: NM, NOM
REAL(EB), DIMENSION(:), POINTER :: OV
INTEGER :: LL, IOR0, ICG, IWG

RECV_BUFFER_REAL => SCARC_POINT_TO_BUFFER_REAL (NM, NOM, 1)

LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   UNPACK_MGM_VELO: DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      IWG = OG%ICG_TO_IWG(ICG)
      SELECT CASE (ABS(IOR0))
         CASE (1)
            OV => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%OU3
         CASE (2)
            OV => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%OV3
         CASE (3)
            OV => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%OW3
      END SELECT
      OV(IWG) = RECV_BUFFER_REAL(LL)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 4I4, 1E14.6)') 'UNPACK_MGM_VELO: NM, NOM, ICG, IWG, OV:', NM, NOM, ICG, IWG, OV(IWG)
#endif
      LL = LL + 1
   ENDDO UNPACK_MGM_VELO
ENDDO
END SUBROUTINE SCARC_UNPACK_MGM_VELO


! ------------------------------------------------------------------------------------------------
!> \brief Unpack overlapping parts of specified pressure vector (predictor/corrector)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_MGM_VELO2(NM, NOM)
USE SCARC_POINTERS, ONLY: OL, OG, RECV_BUFFER_REAL
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_REAL
INTEGER, INTENT(IN) :: NM, NOM
REAL(EB), DIMENSION(:), POINTER :: OH3, OV
INTEGER :: LL, IOR0, ICG, IWG

RECV_BUFFER_REAL => SCARC_POINT_TO_BUFFER_REAL (NM, NOM, 1)
OH3 => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%OH3

LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   UNPACK_MGM_VELO: DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      IWG = OG%ICG_TO_IWG(ICG)
      OH3(IWG) = RECV_BUFFER_REAL(LL)
      SELECT CASE (ABS(IOR0))
         CASE (1)
            OV => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%OU3
         CASE (2)
            OV => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%OV3
         CASE (3)
            OV => SCARC(NM)%LEVEL(NLEVEL_MIN)%MGM%OW3
      END SELECT
      OV(IWG) = RECV_BUFFER_REAL(LL+1)
#ifdef WITH_SCARC_DEBUG
WRITE(MSG%LU_DEBUG,'(A, 4I4, 2E14.6)') 'UNPACK_MGM_VELO: NM, NOM, ICG, IWG, OH3:', NM, NOM, ICG, IWG, OH3(IWG), OV(IWG)
#endif
      LL = LL + 2
   ENDDO UNPACK_MGM_VELO
ENDDO
END SUBROUTINE SCARC_UNPACK_MGM_VELO2


! ------------------------------------------------------------------------------------------------
!> \brief Pack overlapping auxiliary vector 
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_AUXILIARY(NL)
USE SCARC_POINTERS, ONLY: L, G, OL, OG, OS, F
INTEGER, INTENT(IN) :: NL
INTEGER :: IOR0, ICG, ICW1, ICW2, IWG, IXW, IYW, IZW, LL

LL = 1
OS%SEND_BUFFER_REAL = NSCARC_HUGE_REAL_EB
DO IOR0 = -3, 3

   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   F => L%FACE(IOR0)
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)

      ICW1 = OG%ICG_TO_ICW(ICG, 1)
      IF (ICW1 > 0) OS%SEND_BUFFER_REAL(LL) = G%AUX1(ICW1)
      LL = LL + 1

      IF (NL /= NLEVEL_MIN) CYCLE

      IWG  = OG%ICG_TO_IWG(ICG)
      IXW  = G%WALL(IWG)%IXW + F%INCRX
      IYW  = G%WALL(IWG)%IYW + F%INCRY
      IZW  = G%WALL(IWG)%IZW + F%INCRZ

      ICW2 = G%CELL_NUMBER(IXW, IYW, IZW)
      IF (ICW2 > 0) OS%SEND_BUFFER_REAL(LL+1) = G%AUX1(ICW2)
      LL = LL + 1

   ENDDO
ENDDO

END SUBROUTINE SCARC_PACK_AUXILIARY


! ------------------------------------------------------------------------------------------------
!> \brief Unpack overlapping auxiliary vector 
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_AUXILIARY (NM, NOM, NL)
USE SCARC_POINTERS, ONLY: G, OL, OG, RECV_BUFFER_REAL
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_REAL
INTEGER, INTENT(IN) :: NM, NOM, NL
INTEGER :: IOR0, ICG, ICE1, ICE2, LL

RECV_BUFFER_REAL => SCARC_POINT_TO_BUFFER_REAL (NM, NOM, 1)
LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)

      ICE1 = OG%ICG_TO_ICE(ICG,1)
      IF (ICE1 > 0) G%AUX1(ICE1) = RECV_BUFFER_REAL(LL)
      LL = LL + 1

      IF (NL /= NLEVEL_MIN) CYCLE

      ICE2 = OG%ICG_TO_ICE(ICG,2)
      IF (ICE2 > 0) G%AUX1(ICE2) = RECV_BUFFER_REAL(LL+1)
      LL = LL + 1

   ENDDO
ENDDO

END SUBROUTINE SCARC_UNPACK_AUXILIARY


! ------------------------------------------------------------------------------------------------
!> \brief Pack and unpack overlapping nullspace vector 
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_NULLSPACE(NL)
USE SCARC_POINTERS, ONLY: L, G, F, OL, OG, OS
INTEGER, INTENT(IN) :: NL
INTEGER :: IOR0, ICG, ICW1, ICW2, IWG, IXW, IYW, IZW, LL

LL = 1
OS%SEND_BUFFER_REAL = NSCARC_HUGE_REAL_EB
DO IOR0 = -3, 3

   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   F => L%FACE(IOR0)
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)

      ICW1 = OG%ICG_TO_ICW(ICG, 1)
      IF (ICW1 > 0) OS%SEND_BUFFER_REAL(LL)   = G%NULLSPACE(ICW1)
      LL = LL + 1

      IF (NL /= NLEVEL_MIN) CYCLE

      IWG  = OG%ICG_TO_IWG(ICG)
      IXW  = G%WALL(IWG)%IXW + F%INCRX
      IYW  = G%WALL(IWG)%IYW + F%INCRY
      IZW  = G%WALL(IWG)%IZW + F%INCRZ

      ICW2 = G%CELL_NUMBER(IXW, IYW, IZW)
      IF (ICW2 > 0) OS%SEND_BUFFER_REAL(LL+1) = G%NULLSPACE(ICW2)
      LL = LL + 1

   ENDDO
ENDDO

END SUBROUTINE SCARC_PACK_NULLSPACE


! ------------------------------------------------------------------------------------------------
!> \brief Unpack overlapping nullspace vector 
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_NULLSPACE (NM, NOM, NL)
USE SCARC_POINTERS, ONLY: G, OL, OG, RECV_BUFFER_REAL
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_REAL
INTEGER, INTENT(IN) :: NM, NOM, NL
INTEGER :: IOR0, ICG, ICE1, ICE2, LL

RECV_BUFFER_REAL => SCARC_POINT_TO_BUFFER_REAL (NM, NOM, 1)
LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)

      ICE1 = OG%ICG_TO_ICE(ICG,1)
      IF (ICE1 > 0) G%NULLSPACE(ICE1) = RECV_BUFFER_REAL(LL)
      LL = LL + 1

      IF (NL /= NLEVEL_MIN) CYCLE

      ICE2 = OG%ICG_TO_ICE(ICG,2)
      IF (ICE2 > 0) G%NULLSPACE(ICE2) = RECV_BUFFER_REAL(LL+1)
      LL = LL + 1

   ENDDO
ENDDO

END SUBROUTINE SCARC_UNPACK_NULLSPACE


! ------------------------------------------------------------------------------------------------
!> \brief Pack overlapping parts of specified vector VC (numbered via IC values)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_VECTOR_PLAIN(NM, NL, NV)
USE SCARC_POINTERS, ONLY: OL, OG, OS
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_VECTOR
INTEGER, INTENT(IN) :: NM, NL, NV
REAL(EB), DIMENSION(:), POINTER :: VC
INTEGER :: IOR0, ICG, ICW

VC => SCARC_POINT_TO_VECTOR(NM, NL, NV)
OS%SEND_BUFFER_REAL = NSCARC_HUGE_REAL_EB

DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      ICW = OG%ICG_TO_ICW(ICG, 1)
      IF (ICW < 0) CYCLE                                  ! skip solid cells
      OS%SEND_BUFFER_REAL(ICG) = VC(ICW)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'PACK_VECTOR_PLAIN: IOR0, ICG, ICW, REAL(ICG): ', IOR0, ICG, ICW, VC(ICW)
#endif
   ENDDO
ENDDO

#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'PACK: Sizes SEND_BUFFER_REAL, VC=', SIZE(OS%SEND_BUFFER_REAL), SIZE(VC)
WRITE(MSG%LU_DEBUG,'(8E14.6)') OS%SEND_BUFFER_REAL(1:16)
WRITE(MSG%LU_DEBUG,*) 'PACK: VC=', NM, NL
WRITE(MSG%LU_DEBUG,'(8E14.6)') VC
#endif

END SUBROUTINE SCARC_PACK_VECTOR_PLAIN


! ------------------------------------------------------------------------------------------------
!> \brief Unpack overlapping parts of specified vector VC (numbered via IC values)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_VECTOR_PLAIN(NM, NOM, NL, NVECTOR)
USE SCARC_POINTERS, ONLY: OL, OG, RECV_BUFFER_REAL
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_REAL, SCARC_POINT_TO_VECTOR
INTEGER, INTENT(IN) :: NM, NOM, NL, NVECTOR
REAL(EB), DIMENSION(:), POINTER :: VC
INTEGER :: IOR0, LL, ICG, ICE

RECV_BUFFER_REAL => SCARC_POINT_TO_BUFFER_REAL (NM, NOM, 1)
VC => SCARC_POINT_TO_VECTOR(NM, NL, NVECTOR)

#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK: Sizes RECV_BUFFER_REAL, VC=', SIZE(RECV_BUFFER_REAL), SIZE(VC)
WRITE(MSG%LU_DEBUG,'(8E14.6)') RECV_BUFFER_REAL(1:16)
WRITE(MSG%LU_DEBUG,*) 'UNPACK: VC=', NM, NOM, NL
WRITE(MSG%LU_DEBUG,'(8E14.6)') VC
#endif

LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      ICE = OG%ICG_TO_ICE(ICG,1)
      IF (ICE < 0) CYCLE                            ! skip solid cells
      VC(ICE) = RECV_BUFFER_REAL(LL)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK_VECTOR_PLAIN: IOR0, ICG, ICE, VC(ICE): ', IOR0, ICG, ICE, VC(ICE)
#endif
      LL = LL + 1
   ENDDO
ENDDO

END SUBROUTINE SCARC_UNPACK_VECTOR_PLAIN


! ------------------------------------------------------------------------------------------------
!> \brief Pack overlapping and internal parts of specified vector
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_VECTOR_MEAN(NM, NL, NVECTOR)
USE SCARC_POINTERS, ONLY: OL, OG, OS
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_VECTOR
INTEGER, INTENT(IN) :: NM, NL, NVECTOR
REAL(EB), DIMENSION(:), POINTER :: VC
INTEGER :: IOR0, ICG, ICW, ICE, LL

VC => SCARC_POINT_TO_VECTOR(NM, NL, NVECTOR)
LL = 1
OS%SEND_BUFFER_REAL = NSCARC_HUGE_REAL_EB
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      ICW = OG%ICG_TO_ICW(ICG, 1)
      IF (ICW < 0) CYCLE                                          ! skip solid internal cells
      OS%SEND_BUFFER_REAL(LL) = VC(ICW)
      LL = LL + 1
   ENDDO
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      ICE = OG%ICG_TO_ICE(ICG, 1)
      IF (ICE < 0) CYCLE                                          ! skip solid external cells
      OS%SEND_BUFFER_REAL(LL) = VC(ICE)
      LL = LL + 1
   ENDDO
ENDDO

END SUBROUTINE SCARC_PACK_VECTOR_MEAN


! ------------------------------------------------------------------------------------------------
!> \brief Unpack overlapping and internal parts of specified vector
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_VECTOR_MEAN(NM, NOM, NL, NVECTOR)
USE SCARC_POINTERS, ONLY: G, OG, OL, RECV_BUFFER_REAL
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_VECTOR, SCARC_POINT_TO_BUFFER_REAL
INTEGER, INTENT(IN) :: NM, NOM, NL, NVECTOR
REAL(EB), DIMENSION(:), POINTER :: VC
INTEGER :: IOR0, LL, ICG, ICW, ICE

RECV_BUFFER_REAL => SCARC_POINT_TO_BUFFER_REAL (NM, NOM, 1)
VC => SCARC_POINT_TO_VECTOR(NM, NL, NVECTOR)
LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      ICW = G%ICG_TO_ICW(ICG,1)
      IF (ICW < 0) CYCLE                                                       ! skip internal solid cells
      VC(ICW) = 2.0_EB/3.0_EB * VC(ICW) + 1.0_EB/3.0_EB * RECV_BUFFER_REAL(LL)
      !VC(ICW) = 0.5_EB * VC(ICW) + 0.5_EB * RECV_BUFFER_REAL(LL)
      LL = LL + 1
   ENDDO
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      ICE = OG%ICG_TO_ICE(ICG,1)
      IF (ICE < 0) CYCLE                                                       ! skip external solid cells
      VC(ICE) = 1.0_EB/3.0_EB * VC(ICE) + 2.0_EB/3.0_EB * RECV_BUFFER_REAL(LL)
      !VC(ICE) = 0.5_EB * VC(ICE) + 0.5_EB * RECV_BUFFER_REAL(LL)
      LL = LL + 1
   ENDDO
ENDDO

END SUBROUTINE SCARC_UNPACK_VECTOR_MEAN


! ------------------------------------------------------------------------------------------------
!> \brief Pack overlapping information about matrix columns (compact storage technique only)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_MATRIX_COLS(NMATRIX)                
USE SCARC_POINTERS, ONLY: G, OS, OL, OG, AC
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_CMATRIX
INTEGER, INTENT(IN) :: NMATRIX
INTEGER :: IOR0, LL, ICOL, ICG, ICW

AC => SCARC_POINT_TO_CMATRIX(G, NMATRIX)

LL = 1
OS%SEND_BUFFER_INT = NSCARC_HUGE_INT

DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE

#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'PACK_MATRIX_COLS: FIRSTW, LASTW:', OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
#endif
   DO ICG= OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      ICW = OG%ICG_TO_ICW(ICG, 1)
      IF (ICW < 0) CYCLE                               ! skip solid cells
      ICOL = AC%ROW(ICW)
      OS%SEND_BUFFER_INT(LL) = -AC%COL(ICOL)           ! send first element with negative sign (thus, mark beginning)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'PACK_MATRIX_COLS:A: IOR0, ICG, ICW, ICOL, COL:', IOR0, ICG, ICW, ICOL, AC%COL(ICOL)
#endif
      LL = LL + 1                            
      DO ICOL = AC%ROW(ICW)+1, AC%ROW(ICW+1)-1
         OS%SEND_BUFFER_INT(LL) = AC%COL(ICOL)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'PACK_MATRIX_COLS:B: IOR0, ICG, ICW, ICOL, COL:', IOR0, ICG, ICW, ICOL, AC%COL(ICOL)
#endif
         LL = LL + 1
      ENDDO
   ENDDO
ENDDO

END SUBROUTINE SCARC_PACK_MATRIX_COLS


! ------------------------------------------------------------------------------------------------
!> \brief Unpack overlapping information about matrix columns (compact storage technique only)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_MATRIX_COLS(NM, NOM, NMATRIX)
USE SCARC_POINTERS, ONLY: OL, OG, OAC, RECV_BUFFER_INT
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_OTHER_CMATRIX, SCARC_POINT_TO_BUFFER_INT
INTEGER, INTENT(IN) :: NM, NOM, NMATRIX
INTEGER :: IOR0, ICG, LL, ICP

RECV_BUFFER_INT => SCARC_POINT_TO_BUFFER_INT (NM, NOM, 1)
OAC => SCARC_POINT_TO_OTHER_CMATRIX(OG, NMATRIX)

LL = 1                                 
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTE(IOR0) == 0) CYCLE
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK_MATRIX_COLS: FIRSTW, LASTW:', OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
#endif
   ICP = OL%GHOST_FIRSTE(IOR0)
   OAC%ROW(ICP) = LL
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      IF (OG%ICG_TO_ICE(ICG,1) < 0) CYCLE                          ! skip solid cells
      OAC%COL(LL) = ABS(RECV_BUFFER_INT(LL))
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK_MATRIX_COLS:A: IOR0, ICP, ICG, LL, COL:', IOR0, ICP, ICG, LL, OAC%COL(LL)
#endif
      DO WHILE (RECV_BUFFER_INT(LL+1) >= 0)
         LL = LL + 1
         OAC%COL(LL) = ABS(RECV_BUFFER_INT(LL))
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK_MATRIX_COLS:B: IOR0, ICP, ICG, LL, COL:', IOR0, ICP, ICG, LL, OAC%COL(LL)
#endif
      ENDDO
      LL = LL + 1
      ICP = ICP + 1
      OAC%ROW(ICP) = LL
   ENDDO
   OAC%N_ROW = ICP  
   OAC%N_VAL = LL - 1
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK_MATRIX_COLS:OAC%ROW:', OAC%ROW(1:OAC%N_ROW)
#endif
ENDDO

END SUBROUTINE SCARC_UNPACK_MATRIX_COLS


! ------------------------------------------------------------------------------------------------
!> \brief Pack overlapping information about matrix columns (compact storage technique only)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_MATRIX_COLSG(NMATRIX)                
USE SCARC_POINTERS, ONLY: G, OS, OL, OG, AC
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_CMATRIX
INTEGER, INTENT(IN) :: NMATRIX
INTEGER :: IOR0, ICG, ICW, LL, ICOL
INTEGER, POINTER, DIMENSION(:) :: COLG

AC => SCARC_POINT_TO_CMATRIX(G, NMATRIX)
IF (NMESHES == 1 .OR. TYPE_SCOPE(0) == NSCARC_SCOPE_LOCAL) THEN
   COLG => AC%COL
ELSE
   COLG => AC%COLG
ENDIF

LL = 1
OS%SEND_BUFFER_INT = NSCARC_HUGE_INT

DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE

   DO ICG= OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      ICW = OG%ICG_TO_ICW(ICG, 1)
      IF (ICW < 0) CYCLE                               ! skip solid cells
      ICOL = AC%ROW(ICW)
      OS%SEND_BUFFER_INT(LL) = -COLG(ICOL)          ! send first element with negative sign (thus, mark beginning)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'PACK_MATRIX_COLSG:A: IOR0, ICG, ICW, ICOL, COLG:', IOR0, ICG, ICW, ICOL, -COLG(ICOL)
#endif
      LL = LL + 1                              
      DO ICOL = AC%ROW(ICW)+1, AC%ROW(ICW+1)-1
         OS%SEND_BUFFER_INT(LL) = COLG(ICOL)   
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'PACK_MATRIX_COLSG:B: IOR0, ICG, ICW, ICOL, COLG:', IOR0, ICG, ICW, ICOL, COLG(ICOL)
#endif
         LL = LL + 1
      ENDDO
   ENDDO
ENDDO

END SUBROUTINE SCARC_PACK_MATRIX_COLSG


! ------------------------------------------------------------------------------------------------
!> \brief Unpack overlapping information about matrix columns (compact storage technique only)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_MATRIX_COLSG(NM, NOM, NMATRIX)
USE SCARC_POINTERS, ONLY: OL, OG, OAC, RECV_BUFFER_INT
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_OTHER_CMATRIX, SCARC_POINT_TO_BUFFER_INT
INTEGER, INTENT(IN) :: NM, NOM, NMATRIX
INTEGER :: IOR0, ICG, LL, ICP
INTEGER, POINTER, DIMENSION(:) :: COLG

RECV_BUFFER_INT => SCARC_POINT_TO_BUFFER_INT (NM, NOM, 1)
OAC => SCARC_POINT_TO_OTHER_CMATRIX(OG, NMATRIX)
IF (NMESHES == 1 .OR. TYPE_SCOPE(0) == NSCARC_SCOPE_LOCAL) THEN
   COLG => OAC%COL
ELSE
   COLG => OAC%COLG
ENDIF

LL = 1                                 
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTE(IOR0) == 0) CYCLE
   ICP = OL%GHOST_FIRSTE(IOR0)
   OAC%ROW(ICP) = LL
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      IF (OG%ICG_TO_ICE(ICG,1) < 0) CYCLE                     ! skip solid cells
      COLG(LL) = ABS(RECV_BUFFER_INT(LL))
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK_MATRIX_COLSG:A:  IOR0, ICP, ICG, LL, COLG:', IOR0, ICP, ICG, LL, COLG(LL)
#endif
      DO WHILE (RECV_BUFFER_INT(LL+1) > 0)
         LL = LL + 1
         COLG(LL) = ABS(RECV_BUFFER_INT(LL))
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK_MATRIX_COLSG:B:  IOR0, ICP, ICG, LL, COLG:', IOR0, ICP, ICG, LL, COLG(LL)
#endif
      ENDDO
      LL = LL + 1
      ICP = ICP + 1
      OAC%ROW(ICP) = LL
   ENDDO
   OAC%N_ROW = ICP  
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK_MATRIX_COLSG:OAC%ROW:', OAC%ROW(1:OAC%N_ROW)
#endif
   OAC%N_VAL = LL - 1
ENDDO

END SUBROUTINE SCARC_UNPACK_MATRIX_COLSG


! ------------------------------------------------------------------------------------------------
!> \brief Pack overlapping information about matrix values (both storage techniques)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_MATRIX_VALS(NMATRIX, NL)
USE SCARC_POINTERS, ONLY:  G, AB, AC, OS, OL, OG
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BMATRIX, SCARC_POINT_TO_CMATRIX
INTEGER, INTENT(IN) :: NMATRIX, NL
INTEGER :: IOR0, ICG, ICW, LL, ID, ICOL

LL = 1
OS%SEND_BUFFER_INT = NSCARC_ZERO_REAL_EB
SELECT CASE (SCARC_GET_MATRIX_TYPE(NL))

   ! Bandwise matrix on level NL
   CASE (NSCARC_MATRIX_BANDWISE)                

      AB => SCARC_POINT_TO_BMATRIX(G, NMATRIX)
      DO IOR0 = -3, 3
         IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
         DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
            ICW = OG%ICG_TO_ICW(ICG, 1)
            DO ID = 1, AB%N_STENCIL
               OS%SEND_BUFFER_REAL(LL) = AB%VAL(ICW, ID)
               LL = LL + 1
            ENDDO
         ENDDO
      ENDDO

   ! Compact matrix on level NL
   CASE (NSCARC_MATRIX_COMPACT)

      AC => SCARC_POINT_TO_CMATRIX(G, NMATRIX)
      DO IOR0 = -3, 3
         IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
         DO ICG= OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
            ICW = OG%ICG_TO_ICW(ICG, 1)
            IF (ICW < 0) CYCLE                                ! skip solid cells
            DO ICOL = AC%ROW(ICW), AC%ROW(ICW+1)-1
               OS%SEND_BUFFER_REAL(LL) = AC%VAL(ICOL)
               LL = LL + 1
            ENDDO
         ENDDO
      ENDDO

END SELECT

END SUBROUTINE SCARC_PACK_MATRIX_VALS


! ------------------------------------------------------------------------------------------------
!> \brief Unpack overlapping information about matrix values (both storage techniques)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_MATRIX_VALS(NM, NOM, NL, NMATRIX)
USE SCARC_POINTERS, ONLY: OL, OG, OAB, OAC, RECV_BUFFER_REAL
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_OTHER_BMATRIX, SCARC_POINT_TO_OTHER_CMATRIX, &
                                  SCARC_POINT_TO_BUFFER_REAL
INTEGER, INTENT(IN) :: NM, NOM, NL, NMATRIX
INTEGER :: IOR0, ICG, ICOL, ID, LL

RECV_BUFFER_REAL => SCARC_POINT_TO_BUFFER_REAL (NM, NOM, 1)

SELECT CASE (SCARC_GET_MATRIX_TYPE(NL))

   ! Bandwise matrix on level NL
   CASE (NSCARC_MATRIX_BANDWISE)              

      OAB => SCARC_POINT_TO_OTHER_BMATRIX(OG, NMATRIX)
      LL = 1
      DO IOR0 = -3, 3
         IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
         DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
            DO ID = 1, OAB%N_STENCIL
               OAB%VAL(ICG, ID) = RECV_BUFFER_REAL(LL)
               LL = LL + 1
            ENDDO
         ENDDO
      ENDDO

   ! Compact matrix on level NL
   CASE (NSCARC_MATRIX_COMPACT)

      OAC => SCARC_POINT_TO_OTHER_CMATRIX(OG, NMATRIX)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK_MATRIX_VALS:OAC%ROW:', NM, NOM, NL, NMATRIX
WRITE(MSG%LU_DEBUG,*) 'UNPACK_MATRIX_VALS:OAC%ROW:', OAC%ROW(1:OAC%N_ROW)
#endif
      LL = 1
      DO IOR0 = -3, 3
         IF (OL%GHOST_LASTE(IOR0) == 0) CYCLE
         DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
            IF (OG%ICG_TO_ICE(ICG,1) < 0) CYCLE                     ! skip solid cells
            DO ICOL = OAC%ROW(ICG), OAC%ROW(ICG+1)-1
               OAC%VAL(ICOL) = RECV_BUFFER_REAL(LL)
               LL = LL + 1
            ENDDO
         ENDDO
      ENDDO

END SELECT

END SUBROUTINE SCARC_UNPACK_MATRIX_VALS


! ------------------------------------------------------------------------------------------------
!> \brief Pack information about matrix sizes into send vector
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_MATRIX_SIZES(NL)
USE SCARC_POINTERS, ONLY: OS, OG
INTEGER, INTENT(IN) :: NL

SELECT CASE (SCARC_GET_MATRIX_TYPE(NL))
   CASE (NSCARC_MATRIX_BANDWISE)
      OS%SEND_BUFFER_INT0(1) = OG%POISSONB%N_VAL
      OS%SEND_BUFFER_INT0(2) = OG%POISSONB%N_DIAG
      OS%SEND_BUFFER_INT0(3) = OG%POISSONB%N_STENCIL
   CASE (NSCARC_MATRIX_COMPACT)
      OS%SEND_BUFFER_INT0(1) = OG%POISSON%N_VAL
      OS%SEND_BUFFER_INT0(2) = OG%POISSON%N_ROW
      OS%SEND_BUFFER_INT0(3) = OG%POISSON%N_STENCIL
END SELECT

END SUBROUTINE SCARC_PACK_MATRIX_SIZES
   

! ------------------------------------------------------------------------------------------------
!> \brief Unpack information about matrix sizes into send vector
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_MATRIX_SIZES(NM, NOM, NL)
USE SCARC_POINTERS, ONLY: OG, RECV_BUFFER_INT
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_INT
INTEGER, INTENT(IN) :: NM, NOM, NL

RECV_BUFFER_INT => SCARC_POINT_TO_BUFFER_INT (NM, NOM, 0)
SELECT CASE (SCARC_GET_MATRIX_TYPE(NL))
   CASE (NSCARC_MATRIX_BANDWISE)
      OG%POISSONB%N_VAL     = RECV_BUFFER_INT(1)
      OG%POISSONB%N_DIAG    = RECV_BUFFER_INT(2)
      OG%POISSONB%N_STENCIL = RECV_BUFFER_INT(3)
   CASE (NSCARC_MATRIX_COMPACT)
      OG%POISSON%N_VAL     = RECV_BUFFER_INT(1)
      OG%POISSON%N_ROW     = RECV_BUFFER_INT(2)
      OG%POISSON%N_STENCIL = RECV_BUFFER_INT(3)
END SELECT

END SUBROUTINE SCARC_UNPACK_MATRIX_SIZES


! ------------------------------------------------------------------------------------------------
!> \brief Pack overlapping information about matrix diagonals (compact storage technique only)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_MATRIX_DIAGS(NTYPE)
USE SCARC_POINTERS, ONLY:  G, AC, OS, OL, OG
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_CMATRIX
INTEGER, INTENT(IN) :: NTYPE
INTEGER :: IOR0, ICG, ICW, ICOL

AC => SCARC_POINT_TO_CMATRIX(G, NTYPE)

OS%SEND_BUFFER_REAL = NSCARC_ZERO_REAL_EB
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      ICW = OG%ICG_TO_ICW(ICG, 1)
      IF (ICW < 0) CYCLE                                   ! skip solid cells
      ICOL = AC%ROW(ICW)
      OS%SEND_BUFFER_REAL(ICG) = AC%VAL(ICOL)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,'(A,4I8,E14.6)') 'PACK_MATRIX_DIAGS: IOR0, ICG, ICW, ICOL, VAL:', &
                                     IOR0, ICG, ICW, ICOL, AC%VAL(ICOL)
#endif
   ENDDO
ENDDO

END SUBROUTINE SCARC_PACK_MATRIX_DIAGS
      

! ------------------------------------------------------------------------------------------------
!> \brief Unpack overlapping information about matrix diagonals (compact storage technique only)
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_MATRIX_DIAGS(NM, NOM)
USE SCARC_POINTERS, ONLY: G, OL, OG, RECV_BUFFER_REAL
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_REAL
INTEGER, INTENT(IN) :: NM, NOM
INTEGER :: IOR0, ICG, ICE, LL

RECV_BUFFER_REAL => SCARC_POINT_TO_BUFFER_REAL (NM, NOM, 1)
LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      ICE = OG%ICG_TO_ICE(ICG, 1)
      IF (ICE < 0) CYCLE                                   ! skip solid cells
      G%DIAG(ICE) = RECV_BUFFER_REAL(LL)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,'(A, 3I8,E14.6)') 'UNPACK_MATRIX_DIAGS: NOM, IOR0, ICG, ICE, DIAG:', &
                                      IOR0, ICG, ICE, G%DIAG(ICE)
#endif
      LL = LL + 1
   ENDDO
ENDDO

END SUBROUTINE SCARC_UNPACK_MATRIX_DIAGS


! ------------------------------------------------------------------------------------------------
!> \brief Pack zones numbers along interfaces
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_CELL_NEIGHBORS(NL)
USE SCARC_POINTERS, ONLY: L, G, OS, OL, OG, A, F
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_CMATRIX
INTEGER, INTENT(IN) :: NL
INTEGER :: IOR0, ICG, ICW, ICWG, LL, IWG, IXW, IYW, IZW

A => SCARC_POINT_TO_CMATRIX(G, NSCARC_MATRIX_POISSON)
OS%SEND_BUFFER_INT = NSCARC_HUGE_INT
LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      ICW  = OG%ICG_TO_ICW(ICG, 1)                                 ! local cell number adjacent to interface
      ICWG = G%LOCAL_TO_GLOBAL(ICW)                                ! global cell number adjacent to interface
      OS%SEND_BUFFER_INT(LL)   = ICW
      OS%SEND_BUFFER_INT(LL+1) = ICWG
      LL = LL + 2
   ENDDO
   IF (NL /= NLEVEL_MIN) CYCLE
   F => L%FACE(IOR0)
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      IWG  = OG%ICG_TO_IWG(ICG)
      IXW  = G%WALL(IWG)%IXW + F%INCRX
      IYW  = G%WALL(IWG)%IYW + F%INCRY
      IZW  = G%WALL(IWG)%IZW + F%INCRZ
      ICW  = G%CELL_NUMBER(IXW, IYW, IZW)
      OG%ICG_TO_ICW(ICG, 2) = ICW                              
      ICWG = G%LOCAL_TO_GLOBAL(ICW)
      OS%SEND_BUFFER_INT(LL)   = ICW
      OS%SEND_BUFFER_INT(LL+1) = ICWG
      LL = LL + 2
   ENDDO
ENDDO

END SUBROUTINE SCARC_PACK_CELL_NEIGHBORS


! ------------------------------------------------------------------------------------------------
!> \brief Unpack zones numbers along interfaces
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_CELL_NEIGHBORS(NM, NOM, NL)
USE SCARC_POINTERS, ONLY: G, OL, OG, RECV_BUFFER_INT
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_INT
INTEGER, INTENT(IN) :: NM, NOM, NL
INTEGER :: ICG, IOR0, LL, IOFF

CROUTINE = 'SCARC_UNPACK_CELL_NEIGHBORS'

RECV_BUFFER_INT => SCARC_POINT_TO_BUFFER_INT (NM, NOM, 1)

CALL SCARC_ALLOCATE_INT1(OG%ICG_TO_OCELL, 1, 2*OG%NCG, NSCARC_INIT_ZERO, 'G%ICG_TO_OCELL', CROUTINE)
CALL SCARC_ALLOCATE_INT1(OG%ICG_TO_GCELL, 1, 2*OG%NCG, NSCARC_INIT_ZERO, 'G%ICG_TO_GCELL', CROUTINE)

LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      OG%ICG_TO_OCELL(ICG) = RECV_BUFFER_INT(LL)
      OG%ICG_TO_GCELL(ICG) = RECV_BUFFER_INT(LL+1)
      LL = LL + 2
   ENDDO
   IF (NL /= NLEVEL_MIN) CYCLE
   IOFF = OL%GHOST_LASTW(IOR0)
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      G%ICE2 = G%ICE2 + 1
      OG%ICG_TO_OCELL(ICG + IOFF) = RECV_BUFFER_INT(LL)
      OG%ICG_TO_GCELL(ICG + IOFF) = RECV_BUFFER_INT(LL+1)
      OG%ICG_TO_ICE(ICG, 2) = G%ICE2
      LL = LL + 2
   ENDDO
ENDDO

END SUBROUTINE SCARC_UNPACK_CELL_NEIGHBORS


! ------------------------------------------------------------------------------------------------
!> \brief Pack zones numbers along interfaces
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_ZONE_NEIGHBORS(NL)
USE SCARC_POINTERS, ONLY: L, G, OS, OL, OG, A, F
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_CMATRIX
INTEGER, INTENT(IN) :: NL
INTEGER :: IOR0, ICG, ICW, LL, IWG, IXW, IYW, IZW, IZWG

A => SCARC_POINT_TO_CMATRIX(G, NSCARC_MATRIX_POISSON)
OS%SEND_BUFFER_INT = NSCARC_HUGE_INT
LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      ICW  = OG%ICG_TO_ICW(ICG, 1)
      IZW  = G%ZONES_LOCAL(ICW)                                ! local zone number adjacent to interface
      IZWG = G%ZONES_GLOBAL(ICW)                               ! global zone number adjacent to interface
      OS%SEND_BUFFER_INT(LL  ) = IZW
      OS%SEND_BUFFER_INT(LL+1) = IZWG
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'PACK_ZONE_NEIGHBORS:A: ICG, ICW, IZW, IZWG :', ICG, ICW, IZW, IZWG, NL
#endif
      LL = LL + 2
   ENDDO
   IF (NL /= NLEVEL_MIN) CYCLE
   F => L%FACE(IOR0)
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      IWG  = OG%ICG_TO_IWG(ICG)
      IXW  = G%WALL(IWG)%IXW + F%INCRX
      IYW  = G%WALL(IWG)%IYW + F%INCRY
      IZW  = G%WALL(IWG)%IZW + F%INCRZ
      ICW  = G%CELL_NUMBER(IXW, IYW, IZW)
      IZW  = G%ZONES_LOCAL(ICW)                       
      IZWG = G%ZONES_GLOBAL(ICW)                      
      OS%SEND_BUFFER_INT(LL  ) = IZW
      OS%SEND_BUFFER_INT(LL+1) = IZWG
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'PACK_ZONE_NEIGHBORS:B: ICG, IWG, ICW, IZW, IZWG :', ICG, IWG, ICW, IZW, IZWG, NL
#endif
      LL = LL + 2
   ENDDO
ENDDO

END SUBROUTINE SCARC_PACK_ZONE_NEIGHBORS


! ------------------------------------------------------------------------------------------------
!> \brief Unpack zones numbers along interfaces
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_ZONE_NEIGHBORS(NM, NOM, NL)
USE SCARC_POINTERS, ONLY: OL, OG, RECV_BUFFER_INT
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_INT
INTEGER, INTENT(IN) :: NM, NOM, NL
INTEGER :: ICG, IOR0, LL, KK

CROUTINE = 'SCARC_UNPACK_ZONE_NEIGHBORS'
RECV_BUFFER_INT => SCARC_POINT_TO_BUFFER_INT (NM, NOM, 1)

CALL SCARC_ALLOCATE_INT1(OG%ICG_TO_OZONE, 1, 2*OG%NCG, NSCARC_INIT_ZERO, 'G%ICG_TO_OZONE', CROUTINE)
CALL SCARC_ALLOCATE_INT1(OG%ICG_TO_GZONE, 1, 2*OG%NCG, NSCARC_INIT_ZERO, 'G%ICG_TO_GZONE', CROUTINE)

LL = 1
KK = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      OG%ICG_TO_OZONE(KK) = RECV_BUFFER_INT(LL)
      OG%ICG_TO_GZONE(KK) = RECV_BUFFER_INT(LL+1)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK_ZONE_NEIGHBORS:A: ICG, OZONE, GZONE :', &
      ICG, OG%ICG_TO_OZONE(KK), OG%ICG_TO_GZONE(KK) , NL, SIZE(OG%ICG_TO_GZONE)
#endif
      KK = KK + 1
      LL = LL + 2
   ENDDO
   IF (NL /= NLEVEL_MIN) CYCLE
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      OG%ICG_TO_OZONE(KK) = RECV_BUFFER_INT(LL)
      OG%ICG_TO_GZONE(KK) = RECV_BUFFER_INT(LL+1)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK_ZONE_NEIGHBORS:B: ICG, OZONE, GZONE :', &
      ICG, OG%ICG_TO_OZONE(KK), OG%ICG_TO_GZONE(KK) , NL, SIZE(OG%ICG_TO_GZONE)
#endif
      KK = KK + 1
      LL = LL + 2
   ENDDO
ENDDO
END SUBROUTINE SCARC_UNPACK_ZONE_NEIGHBORS


! ------------------------------------------------------------------------------------------------
!> \brief Pack zones numbers along interfaces
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_LAYER2_NUMS
USE SCARC_POINTERS, ONLY: OS, OL, OG, L, G
INTEGER :: IOR0, ICG, INUM

CALL SCARC_ALLOCATE_INT1(G%ELAYER2_NUMS, 1, G%NCE2 - G%NC + 1, NSCARC_INIT_ZERO, 'G%ELAYER2_NUMS', CROUTINE)

OS%SEND_BUFFER_INT = NSCARC_HUGE_INT
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      INUM = OG%ICG_TO_ELAYER2(ICG)
      OS%SEND_BUFFER_INT(ICG) = INUM
      IF (INUM /= 0) THEN 
         L%N_LAYER2_TOTAL = L%N_LAYER2_TOTAL + 1
         G%ELAYER2_NUMS(L%N_LAYER2_TOTAL) = OG%ICG_TO_ELAYER2(ICG)
      ENDIF
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'PACK_LAYER2_NUMS: ICG, L%N_LAYER2_TOTAL, SEND_BUFFER_INT(ICG):', &
                       ICG, L%N_LAYER2_TOTAL, OS%SEND_BUFFER_INT(ICG)
#endif
   ENDDO
ENDDO

END SUBROUTINE SCARC_PACK_LAYER2_NUMS


! ------------------------------------------------------------------------------------------------
!> \brief Unpack zones numbers along interfaces
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_LAYER2_NUMS(NM, NOM)
USE SCARC_POINTERS, ONLY: OL, OG, RECV_BUFFER_INT
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_INT
INTEGER, INTENT(IN) :: NM, NOM
INTEGER :: ICG, IOR0

CROUTINE = 'SCARC_UNPACK_LAYER2_NUMS'
RECV_BUFFER_INT => SCARC_POINT_TO_BUFFER_INT (NM, NOM, 1)

CALL SCARC_ALLOCATE_INT1(OG%ICG_TO_ILAYER2, 1, 2*OG%NCG, NSCARC_INIT_ZERO, 'OG%ICG_TO_ILAYER2', CROUTINE)

DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      OG%ICG_TO_ILAYER2(ICG) = RECV_BUFFER_INT(ICG)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK_LAYER2_NUMS: ICG, LAYER2_NUMS:', ICG, RECV_BUFFER_INT(ICG), G%NCE2
#endif
   ENDDO
ENDDO
END SUBROUTINE SCARC_UNPACK_LAYER2_NUMS


! ------------------------------------------------------------------------------------------------
!> \brief Pack zones numbers along interfaces
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_LAYER2_VALS
USE SCARC_POINTERS, ONLY: G, OS, OL, OG
INTEGER :: IOR0, ICG, IC

OS%SEND_BUFFER_REAL = NSCARC_HUGE_INT
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      IC = FINDLOC (G%LOCAL_TO_GLOBAL(1:G%NC), VALUE = OG%ICG_TO_ILAYER2(ICG), DIM = 1)
      IF (IC /= 0) OS%SEND_BUFFER_REAL(ICG) = G%NULLSPACE(IC)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'PACK_LAYER2_VALS: ICG, IC, SEND_BUFFER_REAL(ICG):', ICG, IC, OS%SEND_BUFFER_REAL(ICG)
#endif
   ENDDO
ENDDO

END SUBROUTINE SCARC_PACK_LAYER2_VALS


! ------------------------------------------------------------------------------------------------
!> \brief Unpack zones numbers along interfaces
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_LAYER2_VALS(NM, NOM)
USE SCARC_POINTERS, ONLY: L, OL, G, OG, RECV_BUFFER_REAL
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_REAL
INTEGER, INTENT(IN) :: NM, NOM
INTEGER :: ICG, IOR0

CROUTINE = 'SCARC_UNPACK_LAYER2_VALS'
RECV_BUFFER_REAL => SCARC_POINT_TO_BUFFER_REAL (NM, NOM, 1)

CALL SCARC_ALLOCATE_REAL1(G%ELAYER2_VALS, 1, L%N_LAYER2_TOTAL, NSCARC_INIT_ZERO, 'G%ELAYER2_VALS', CROUTINE)

DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      IF (OG%ICG_TO_ELAYER2(ICG) /= 0) THEN
         L%L2PTR = L%L2PTR + 1
         G%ELAYER2_VALS(L%L2PTR) = RECV_BUFFER_REAL(ICG)
#ifdef WITH_SCARC_DEBUG2
WRITE(MSG%LU_DEBUG,*) 'UNPACK_LAYER2_VALS: ICG, L%L2PTR, G%ELAYER2_VALS:', ICG, L%L2PTR, G%ELAYER2_VALS(L%L2PTR)
#endif
      ENDIF
   ENDDO
ENDDO
END SUBROUTINE SCARC_UNPACK_LAYER2_VALS


! ------------------------------------------------------------------------------------------------
!> \brief Pack zones information into send vector
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_PACK_ZONE_TYPES
USE SCARC_POINTERS, ONLY: G, OS, OL, OG
INTEGER :: IOR0, ICG, ICW, ICE, LL

LL = 1
OS%SEND_BUFFER_INT = NSCARC_HUGE_INT
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE

   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      ICW = OG%ICG_TO_ICW(ICG, 1)
      IF (G%ZONES_LOCAL(ICW) /= 0) THEN
         OS%SEND_BUFFER_INT(LL)   = G%ZONES_LOCAL(ICW)
      ELSE
         OS%SEND_BUFFER_INT(LL)   = 0
      ENDIF
      LL = LL + 1
   ENDDO
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      ICE = OG%ICG_TO_ICE(ICG, 1)
      IF (G%ZONES_LOCAL(ICW) /= 0) THEN
         OS%SEND_BUFFER_INT(LL) = G%ZONES_LOCAL(ICE)
      ELSE
         OS%SEND_BUFFER_INT(LL) = 0
      ENDIF
      LL = LL + 1
   ENDDO
ENDDO
END SUBROUTINE SCARC_PACK_ZONE_TYPES


! ------------------------------------------------------------------------------------------------
!> \brief Unpack zones information into send vector
! ------------------------------------------------------------------------------------------------
SUBROUTINE SCARC_UNPACK_ZONE_TYPES(NM, NOM)
USE SCARC_POINTERS, ONLY: G, OL, OG, RECV_BUFFER_INT
USE SCARC_POINTER_ROUTINES, ONLY: SCARC_POINT_TO_BUFFER_INT
INTEGER, INTENT(IN) :: NM, NOM
INTEGER :: IOR0, LL, ICG, ICW, ICE

RECV_BUFFER_INT => SCARC_POINT_TO_BUFFER_INT (NM, NOM, 1)
LL = 1
DO IOR0 = -3, 3
   IF (OL%GHOST_LASTW(IOR0) == 0) CYCLE
   DO ICG = OL%GHOST_FIRSTE(IOR0), OL%GHOST_LASTE(IOR0)
      ICE = OG%ICG_TO_ICE(ICG, 1)
      IF (G%ZONES_LOCAL(ICE) == 0) G%ZONES_LOCAL(ICE) = RECV_BUFFER_INT(LL)
      LL = LL + 1
   ENDDO
   DO ICG = OL%GHOST_FIRSTW(IOR0), OL%GHOST_LASTW(IOR0)
      ICW = OG%ICG_TO_ICW(ICG, 1)
      IF (G%ZONES_LOCAL(ICW) == 0) G%ZONES_LOCAL(ICW) = RECV_BUFFER_INT(LL)
      LL = LL + 1
   ENDDO
ENDDO

END SUBROUTINE SCARC_UNPACK_ZONE_TYPES



END MODULE SCARC_MPI
