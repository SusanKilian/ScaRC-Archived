<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ScaRC: scrc Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ScaRC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions/Subroutines</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">scrc Module Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Alternative solution of the FDS pressure equation by Scalable Recursive Clustering (ScaRC)  
<a href="namespacescrc.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:ad085f21394faa1b5931ccef7c02b5a2f"><td class="memItemLeft" align="right" valign="top"><a id="ad085f21394faa1b5931ccef7c02b5a2f"></a>
subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ad085f21394faa1b5931ccef7c02b5a2f">scarc_setup</a></td></tr>
<tr class="memdesc:ad085f21394faa1b5931ccef7c02b5a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize ScaRC structures based on SCARC-input parameters from &amp;PRES namelist. <br /></td></tr>
<tr class="separator:ad085f21394faa1b5931ccef7c02b5a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac07c2c880ca15c9f8370c042177005"><td class="memItemLeft" align="right" valign="top"><a id="a7ac07c2c880ca15c9f8370c042177005"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a7ac07c2c880ca15c9f8370c042177005">scarc_setup_memory_management</a></td></tr>
<tr class="memdesc:a7ac07c2c880ca15c9f8370c042177005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup memory management. <br /></td></tr>
<tr class="separator:a7ac07c2c880ca15c9f8370c042177005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576fc7b368bc3214ab9b87677bc62dce"><td class="memItemLeft" align="right" valign="top"><a id="a576fc7b368bc3214ab9b87677bc62dce"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a576fc7b368bc3214ab9b87677bc62dce">scarc_setup_time_measurements</a></td></tr>
<tr class="memdesc:a576fc7b368bc3214ab9b87677bc62dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup time measurements. <br /></td></tr>
<tr class="separator:a576fc7b368bc3214ab9b87677bc62dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ee5f60ba0aaacb709cd3b054c4e534"><td class="memItemLeft" align="right" valign="top"><a id="ac4ee5f60ba0aaacb709cd3b054c4e534"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac4ee5f60ba0aaacb709cd3b054c4e534">scarc_setup_message_services</a></td></tr>
<tr class="memdesc:ac4ee5f60ba0aaacb709cd3b054c4e534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup debug file if requested. <br /></td></tr>
<tr class="separator:ac4ee5f60ba0aaacb709cd3b054c4e534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32f6f801d3b5c998cfa3c89c5669fdd"><td class="memItemLeft" align="right" valign="top"><a id="ae32f6f801d3b5c998cfa3c89c5669fdd"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae32f6f801d3b5c998cfa3c89c5669fdd">scarc_shutdown</a> (NERROR, CPARAM, NPARAM)</td></tr>
<tr class="memdesc:ae32f6f801d3b5c998cfa3c89c5669fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown ScaRC with error message. <br /></td></tr>
<tr class="separator:ae32f6f801d3b5c998cfa3c89c5669fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faf83cd3f4d5766d3a5075266a0ec40"><td class="memItemLeft" align="right" valign="top"><a id="a0faf83cd3f4d5766d3a5075266a0ec40"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a0faf83cd3f4d5766d3a5075266a0ec40">scarc_parse_input</a></td></tr>
<tr class="memdesc:a0faf83cd3f4d5766d3a5075266a0ec40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine types of input parameters. <br /></td></tr>
<tr class="separator:a0faf83cd3f4d5766d3a5075266a0ec40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0c0da2441fa9ea4e48788b697f4e14"><td class="memItemLeft" align="right" valign="top"><a id="a1d0c0da2441fa9ea4e48788b697f4e14"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a1d0c0da2441fa9ea4e48788b697f4e14">scarc_setup_levels</a></td></tr>
<tr class="memdesc:a1d0c0da2441fa9ea4e48788b697f4e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine number of grid levels. <br /></td></tr>
<tr class="separator:a1d0c0da2441fa9ea4e48788b697f4e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ef5ff1c47624fd8b989ae918ca0093"><td class="memItemLeft" align="right" valign="top"><a id="a22ef5ff1c47624fd8b989ae918ca0093"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a22ef5ff1c47624fd8b989ae918ca0093">scarc_get_number_of_levels</a> (NTYPE)</td></tr>
<tr class="memdesc:a22ef5ff1c47624fd8b989ae918ca0093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup single level in case of default Krylov method. <br /></td></tr>
<tr class="separator:a22ef5ff1c47624fd8b989ae918ca0093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2188806799b94039c7b2b9c907db1c97"><td class="memItemLeft" align="right" valign="top"><a id="a2188806799b94039c7b2b9c907db1c97"></a>
integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a2188806799b94039c7b2b9c907db1c97">scarc_get_max_level</a> (NC, IOR0)</td></tr>
<tr class="memdesc:a2188806799b94039c7b2b9c907db1c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine maximum number of possible levels. <br /></td></tr>
<tr class="separator:a2188806799b94039c7b2b9c907db1c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06795bb01666c2cc16defcea18527df8"><td class="memItemLeft" align="right" valign="top"><a id="a06795bb01666c2cc16defcea18527df8"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a06795bb01666c2cc16defcea18527df8">scarc_setup_types</a></td></tr>
<tr class="memdesc:a06795bb01666c2cc16defcea18527df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate basic ScaRC-structures for all needed levels. <br /></td></tr>
<tr class="separator:a06795bb01666c2cc16defcea18527df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d18df0fa476b6051248a898df6f646"><td class="memItemLeft" align="right" valign="top"><a id="a74d18df0fa476b6051248a898df6f646"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a74d18df0fa476b6051248a898df6f646">scarc_assign_grid_type</a> (NTYPE)</td></tr>
<tr class="memdesc:a74d18df0fa476b6051248a898df6f646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign handles to currently used grid type. <br /></td></tr>
<tr class="separator:a74d18df0fa476b6051248a898df6f646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106d5a0046bf6e200f1c60c158969c2f"><td class="memItemLeft" align="right" valign="top"><a id="a106d5a0046bf6e200f1c60c158969c2f"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a106d5a0046bf6e200f1c60c158969c2f">scarc_setup_grids</a></td></tr>
<tr class="memdesc:a106d5a0046bf6e200f1c60c158969c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup discretization information. <br /></td></tr>
<tr class="separator:a106d5a0046bf6e200f1c60c158969c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81448915811a0df3ab730971485961e"><td class="memItemLeft" align="right" valign="top"><a id="ae81448915811a0df3ab730971485961e"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae81448915811a0df3ab730971485961e">scarc_setup_grid_level</a> (NL)</td></tr>
<tr class="memdesc:ae81448915811a0df3ab730971485961e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup discretization information on coarser levels. <br /></td></tr>
<tr class="separator:ae81448915811a0df3ab730971485961e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66501abca64164ca73f1c5f23d731ce3"><td class="memItemLeft" align="right" valign="top"><a id="a66501abca64164ca73f1c5f23d731ce3"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a66501abca64164ca73f1c5f23d731ce3">scarc_setup_neighbors</a></td></tr>
<tr class="memdesc:a66501abca64164ca73f1c5f23d731ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup neighborship structure for data exchanges along mesh interfaces. <br /></td></tr>
<tr class="separator:a66501abca64164ca73f1c5f23d731ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0da6d8c6bd76b3dc67b2a81ffced394"><td class="memItemLeft" align="right" valign="top"><a id="ac0da6d8c6bd76b3dc67b2a81ffced394"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac0da6d8c6bd76b3dc67b2a81ffced394">scarc_setup_faces</a></td></tr>
<tr class="memdesc:ac0da6d8c6bd76b3dc67b2a81ffced394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup structures related to mesh faces on finest grid level. <br /></td></tr>
<tr class="separator:ac0da6d8c6bd76b3dc67b2a81ffced394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823ac1b1ea0e3d082378c7e2e75fcb52"><td class="memItemLeft" align="right" valign="top"><a id="a823ac1b1ea0e3d082378c7e2e75fcb52"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a823ac1b1ea0e3d082378c7e2e75fcb52">scarc_setup_subdivision</a></td></tr>
<tr class="memdesc:a823ac1b1ea0e3d082378c7e2e75fcb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup subdivision information. <br /></td></tr>
<tr class="separator:a823ac1b1ea0e3d082378c7e2e75fcb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd663790be6311dd395780f9f1385e9"><td class="memItemLeft" align="right" valign="top"><a id="aebd663790be6311dd395780f9f1385e9"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aebd663790be6311dd395780f9f1385e9">scarc_setup_face_basics</a> (NM, NL)</td></tr>
<tr class="memdesc:aebd663790be6311dd395780f9f1385e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine basic data for single faces (orientation, dimensions, numbers) <br /></td></tr>
<tr class="separator:aebd663790be6311dd395780f9f1385e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38edaa44f9218d266f4d644d153f892"><td class="memItemLeft" align="right" valign="top"><a id="aa38edaa44f9218d266f4d644d153f892"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aa38edaa44f9218d266f4d644d153f892">scarc_setup_walls</a></td></tr>
<tr class="memdesc:aa38edaa44f9218d266f4d644d153f892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup wall related structures and boundary conditions. <br /></td></tr>
<tr class="separator:aa38edaa44f9218d266f4d644d153f892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c41faee472ea46c49a311d34795d77d"><td class="memItemLeft" align="right" valign="top"><a id="a5c41faee472ea46c49a311d34795d77d"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a5c41faee472ea46c49a311d34795d77d">scarc_setup_exchanges</a></td></tr>
<tr class="memdesc:a5c41faee472ea46c49a311d34795d77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate workspace for data exchanges of different data types and sizes and perform basic exchanges. <br /></td></tr>
<tr class="separator:a5c41faee472ea46c49a311d34795d77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3177ea7f48f22cc0b8bf16aa33f4c62f"><td class="memItemLeft" align="right" valign="top"><a id="a3177ea7f48f22cc0b8bf16aa33f4c62f"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a3177ea7f48f22cc0b8bf16aa33f4c62f">scarc_store_neighbor</a> (NM, NOM)</td></tr>
<tr class="memdesc:a3177ea7f48f22cc0b8bf16aa33f4c62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store all neighbors of a mesh. <br /></td></tr>
<tr class="separator:a3177ea7f48f22cc0b8bf16aa33f4c62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1534f65ba4642a233efa20c862417e"><td class="memItemLeft" align="right" valign="top"><a id="a5f1534f65ba4642a233efa20c862417e"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a5f1534f65ba4642a233efa20c862417e">scarc_setup_cell_index</a> (NM, NL)</td></tr>
<tr class="memdesc:a5f1534f65ba4642a233efa20c862417e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup cells indexing array on coarser grid levels in case of MG-method. <br /></td></tr>
<tr class="separator:a5f1534f65ba4642a233efa20c862417e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1041b6a2e72ee0a3754993d77d8dcc"><td class="memItemLeft" align="right" valign="top"><a id="ace1041b6a2e72ee0a3754993d77d8dcc"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ace1041b6a2e72ee0a3754993d77d8dcc">scarc_setup_wall_index</a> (NM, NL)</td></tr>
<tr class="memdesc:ace1041b6a2e72ee0a3754993d77d8dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup wall cells indexing array on coarser grid levels. <br /></td></tr>
<tr class="separator:ace1041b6a2e72ee0a3754993d77d8dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0edf450fa9efc079890b23771a9d705"><td class="memItemLeft" align="right" valign="top"><a id="ab0edf450fa9efc079890b23771a9d705"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab0edf450fa9efc079890b23771a9d705">scarc_setup_wall_ghosts</a> (NM, NL)</td></tr>
<tr class="memdesc:ab0edf450fa9efc079890b23771a9d705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup order in which ghost cells are processed during data exchanges. <br /></td></tr>
<tr class="separator:ab0edf450fa9efc079890b23771a9d705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0601aa581d8cfa14517f9f83021757"><td class="memItemLeft" align="right" valign="top"><a id="a7c0601aa581d8cfa14517f9f83021757"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a7c0601aa581d8cfa14517f9f83021757">scarc_setup_wall_coords</a> (NM, NL)</td></tr>
<tr class="memdesc:a7c0601aa581d8cfa14517f9f83021757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup all necessary information for a wall cell with neighbor in case of MG-method. <br /></td></tr>
<tr class="separator:a7c0601aa581d8cfa14517f9f83021757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfed0cd663e05d394a47f9950ff7a14"><td class="memItemLeft" align="right" valign="top"><a id="a6dfed0cd663e05d394a47f9950ff7a14"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a6dfed0cd663e05d394a47f9950ff7a14">scarc_identify_internal_neumanns</a> (NM, NL)</td></tr>
<tr class="memdesc:a6dfed0cd663e05d394a47f9950ff7a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correct boundary type array related to internal obstructions on ghost cells. <br /></td></tr>
<tr class="separator:a6dfed0cd663e05d394a47f9950ff7a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45521ea4c41925b55a31a3ba3e69c9e"><td class="memItemLeft" align="right" valign="top"><a id="ac45521ea4c41925b55a31a3ba3e69c9e"></a>
integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac45521ea4c41925b55a31a3ba3e69c9e">scarc_count_external_wall_cells</a> (NM, NL)</td></tr>
<tr class="memdesc:ac45521ea4c41925b55a31a3ba3e69c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup all necessary information for a wall cell with neighbor. <br /></td></tr>
<tr class="separator:ac45521ea4c41925b55a31a3ba3e69c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243619b6213c93e425b56911f9b3bc44"><td class="memItemLeft" align="right" valign="top"><a id="a243619b6213c93e425b56911f9b3bc44"></a>
integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a243619b6213c93e425b56911f9b3bc44">scarc_count_internal_wall_cells</a> (NM, NL)</td></tr>
<tr class="memdesc:a243619b6213c93e425b56911f9b3bc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup all necessary information for a wall cell with neighbor. <br /></td></tr>
<tr class="separator:a243619b6213c93e425b56911f9b3bc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecddf03b23ece5d70a082ee9b00232a"><td class="memItemLeft" align="right" valign="top"><a id="afecddf03b23ece5d70a082ee9b00232a"></a>
logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#afecddf03b23ece5d70a082ee9b00232a">is_external_wallcell</a> (IOR0, ICF, NCNT, NM, NL)</td></tr>
<tr class="memdesc:afecddf03b23ece5d70a082ee9b00232a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count external wall cells on specified face if mesh. <br /></td></tr>
<tr class="separator:afecddf03b23ece5d70a082ee9b00232a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d13f584b7afccc293a949a9f2d14e2"><td class="memItemLeft" align="right" valign="top"><a id="a86d13f584b7afccc293a949a9f2d14e2"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a86d13f584b7afccc293a949a9f2d14e2">scarc_setup_wall_neighbor</a> (NX1, NX2, NY1, NY2, NZ1, NZ2, IWG, NM, NOM, NL)</td></tr>
<tr class="memdesc:a86d13f584b7afccc293a949a9f2d14e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup all necessary information for a wall cell with neighbor. <br /></td></tr>
<tr class="separator:a86d13f584b7afccc293a949a9f2d14e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd255e7b26fa7c8e1339b198a82ee86c"><td class="memItemLeft" align="right" valign="top"><a id="afd255e7b26fa7c8e1339b198a82ee86c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#afd255e7b26fa7c8e1339b198a82ee86c">scarc_check_divisibility</a> (NN, CDIR)</td></tr>
<tr class="memdesc:afd255e7b26fa7c8e1339b198a82ee86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check divisibility by 2 of a given number of elements (in one grid direction) <br /></td></tr>
<tr class="separator:afd255e7b26fa7c8e1339b198a82ee86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae243e00872dfd923c4b5e18da2f1bb67"><td class="memItemLeft" align="right" valign="top"><a id="ae243e00872dfd923c4b5e18da2f1bb67"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae243e00872dfd923c4b5e18da2f1bb67">scarc_setup_wall_level</a> (IOR0, IWC, IREFINE, NM, NL)</td></tr>
<tr class="memdesc:ae243e00872dfd923c4b5e18da2f1bb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set wall cell information on coarse level. <br /></td></tr>
<tr class="separator:ae243e00872dfd923c4b5e18da2f1bb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3f79fca28037ff44d45d2ca9a90eec"><td class="memItemLeft" align="right" valign="top"><a id="aab3f79fca28037ff44d45d2ca9a90eec"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aab3f79fca28037ff44d45d2ca9a90eec">scarc_setup_exchange_dimensions</a> (IREFINE, NM, NOM, NL)</td></tr>
<tr class="memdesc:aab3f79fca28037ff44d45d2ca9a90eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup dimensions for data exchanges. <br /></td></tr>
<tr class="separator:aab3f79fca28037ff44d45d2ca9a90eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918c071a0578fc0f3f35ea3935f9ce67"><td class="memItemLeft" align="right" valign="top"><a id="a918c071a0578fc0f3f35ea3935f9ce67"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a918c071a0578fc0f3f35ea3935f9ce67">scarc_setup_globals</a></td></tr>
<tr class="memdesc:a918c071a0578fc0f3f35ea3935f9ce67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate several global structures for data exchange. <br /></td></tr>
<tr class="separator:a918c071a0578fc0f3f35ea3935f9ce67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7d508f2a5fc27ef2b15853cb3b1afd"><td class="memItemLeft" align="right" valign="top"><a id="a4d7d508f2a5fc27ef2b15853cb3b1afd"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a4d7d508f2a5fc27ef2b15853cb3b1afd">scarc_setup_dimensions</a> (NL)</td></tr>
<tr class="memdesc:a4d7d508f2a5fc27ef2b15853cb3b1afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about global numbers of unknowns for unstructured discretization. <br /></td></tr>
<tr class="separator:a4d7d508f2a5fc27ef2b15853cb3b1afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3785bd6f33497a75694b5c1efc94b09"><td class="memItemLeft" align="right" valign="top"><a id="ae3785bd6f33497a75694b5c1efc94b09"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae3785bd6f33497a75694b5c1efc94b09">scarc_setup_systems</a></td></tr>
<tr class="memdesc:ae3785bd6f33497a75694b5c1efc94b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup system of equations (Poisson matrix + BC's) for different variants of ScaRC. <br /></td></tr>
<tr class="separator:ae3785bd6f33497a75694b5c1efc94b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caae41662e629365cecccbd245c94ce"><td class="memItemLeft" align="right" valign="top"><a id="a2caae41662e629365cecccbd245c94ce"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a2caae41662e629365cecccbd245c94ce">scarc_setup_global_cell_numbering</a> (NL)</td></tr>
<tr class="memdesc:a2caae41662e629365cecccbd245c94ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup mapping vector from local to global numbering. <br /></td></tr>
<tr class="separator:a2caae41662e629365cecccbd245c94ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5020358919e9eaf272d3e93fefa18baa"><td class="memItemLeft" align="right" valign="top"><a id="a5020358919e9eaf272d3e93fefa18baa"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a5020358919e9eaf272d3e93fefa18baa">scarc_setup_global_matrix_numbering</a> (NMATRIX, NL)</td></tr>
<tr class="memdesc:a5020358919e9eaf272d3e93fefa18baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract overlapping matrix part and add to main matrix. <br /></td></tr>
<tr class="separator:a5020358919e9eaf272d3e93fefa18baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6fcd74f0cdb9bf645d5614f72ca6d3"><td class="memItemLeft" align="right" valign="top"><a id="a0c6fcd74f0cdb9bf645d5614f72ca6d3"></a>
logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a0c6fcd74f0cdb9bf645d5614f72ca6d3">scarc_cell_within_mesh</a> (G, NM, IC)</td></tr>
<tr class="memdesc:a0c6fcd74f0cdb9bf645d5614f72ca6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if specified cell is within a given mesh. <br /></td></tr>
<tr class="separator:a0c6fcd74f0cdb9bf645d5614f72ca6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae188b03fa40f278e7c83a6e1e2febbce"><td class="memItemLeft" align="right" valign="top"><a id="ae188b03fa40f278e7c83a6e1e2febbce"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae188b03fa40f278e7c83a6e1e2febbce">scarc_setup_poisson</a> (NM, NL)</td></tr>
<tr class="memdesc:ae188b03fa40f278e7c83a6e1e2febbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate Poisson matrix for the usual 5-point-stencil (2D) or 7-point-stencil (3D) <br /></td></tr>
<tr class="separator:ae188b03fa40f278e7c83a6e1e2febbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababe6effa7cd0e8f0bb7704ad0706aad"><td class="memItemLeft" align="right" valign="top"><a id="ababe6effa7cd0e8f0bb7704ad0706aad"></a>
logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ababe6effa7cd0e8f0bb7704ad0706aad">valid_subdiag</a> (IX, IY, IZ, IOR0)</td></tr>
<tr class="memdesc:ababe6effa7cd0e8f0bb7704ad0706aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a subdiagonal entry must be computed in a specified coordinate direction. <br /></td></tr>
<tr class="separator:ababe6effa7cd0e8f0bb7704ad0706aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bdc3364edc79f59b56949f2d37a8b4"><td class="memItemLeft" align="right" valign="top"><a id="a57bdc3364edc79f59b56949f2d37a8b4"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a57bdc3364edc79f59b56949f2d37a8b4">scarc_setup_poissonc_maindiag</a> (IC, IX, IY, IZ, IP)</td></tr>
<tr class="memdesc:a57bdc3364edc79f59b56949f2d37a8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set main diagonal entry for Poisson matrix in compact storage technique. <br /></td></tr>
<tr class="separator:a57bdc3364edc79f59b56949f2d37a8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc92614fa3f96d474a9a1a8bb05960d"><td class="memItemLeft" align="right" valign="top"><a id="aebc92614fa3f96d474a9a1a8bb05960d"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aebc92614fa3f96d474a9a1a8bb05960d">scarc_setup_poissonc_subdiag</a> (IC, IX1, IY1, IZ1, IX2, IY2, IZ2, IP, IOR0)</td></tr>
<tr class="memdesc:aebc92614fa3f96d474a9a1a8bb05960d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set subdigonal entries for Poisson matrix in compact storage technique on specified face. <br /></td></tr>
<tr class="separator:aebc92614fa3f96d474a9a1a8bb05960d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40299dd71945ad4dc092ca9e69e136f1"><td class="memItemLeft" align="right" valign="top"><a id="a40299dd71945ad4dc092ca9e69e136f1"></a>
integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a40299dd71945ad4dc092ca9e69e136f1">scarc_assign_subdiag_type</a> (IC, IOR0)</td></tr>
<tr class="memdesc:a40299dd71945ad4dc092ca9e69e136f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if cell has a neighbor and, if yes, return corresponding wall cell index. <br /></td></tr>
<tr class="separator:a40299dd71945ad4dc092ca9e69e136f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b4c10746de76749191026a2f617176"><td class="memItemLeft" align="right" valign="top"><a id="a55b4c10746de76749191026a2f617176"></a>
integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a55b4c10746de76749191026a2f617176">scarc_matrix_level</a> (NL)</td></tr>
<tr class="memdesc:a55b4c10746de76749191026a2f617176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of matrix storage scheme for specified grid level. <br /></td></tr>
<tr class="separator:a55b4c10746de76749191026a2f617176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4826db5f0559a9d2c7593aa8e9efc2fa"><td class="memItemLeft" align="right" valign="top"><a id="a4826db5f0559a9d2c7593aa8e9efc2fa"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a4826db5f0559a9d2c7593aa8e9efc2fa">scarc_setup_poissonb_maindiag</a> (IC, IX, IY, IZ)</td></tr>
<tr class="memdesc:a4826db5f0559a9d2c7593aa8e9efc2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set main diagonal entry for Poisson matrix in bandwise storage technique. <br /></td></tr>
<tr class="separator:a4826db5f0559a9d2c7593aa8e9efc2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65adb17de6578e4720facc82fda6a9a7"><td class="memItemLeft" align="right" valign="top"><a id="a65adb17de6578e4720facc82fda6a9a7"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a65adb17de6578e4720facc82fda6a9a7">scarc_setup_poissonb_subdiag</a> (IC, IX1, IY1, IZ1, IX2, IY2, IZ2, IOR0)</td></tr>
<tr class="memdesc:a65adb17de6578e4720facc82fda6a9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set subdigonal entries for Poisson matrix in bandwise storage technique on specified face. <br /></td></tr>
<tr class="separator:a65adb17de6578e4720facc82fda6a9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3b26ff7207afe6e716c3b8e91ffd06"><td class="memItemLeft" align="right" valign="top"><a id="a3c3b26ff7207afe6e716c3b8e91ffd06"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a3c3b26ff7207afe6e716c3b8e91ffd06">scarc_get_matrix_stencil_max</a> (A, NLEN)</td></tr>
<tr class="memdesc:a3c3b26ff7207afe6e716c3b8e91ffd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum stencil size in specified matrix. <br /></td></tr>
<tr class="separator:a3c3b26ff7207afe6e716c3b8e91ffd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffde86c8d5f1bb8af187207d0a5f6c7"><td class="memItemLeft" align="right" valign="top"><a id="a9ffde86c8d5f1bb8af187207d0a5f6c7"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a9ffde86c8d5f1bb8af187207d0a5f6c7">scarc_setup_poisson_mkl</a> (NM, NL)</td></tr>
<tr class="memdesc:a9ffde86c8d5f1bb8af187207d0a5f6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup symmetric version of Poisson matrix for MKL solver in double precision. <br /></td></tr>
<tr class="separator:a9ffde86c8d5f1bb8af187207d0a5f6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6dc3334b73fd7152b171cef312ceb94"><td class="memItemLeft" align="right" valign="top"><a id="ac6dc3334b73fd7152b171cef312ceb94"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac6dc3334b73fd7152b171cef312ceb94">scarc_setup_boundary</a> (NM, NL)</td></tr>
<tr class="memdesc:ac6dc3334b73fd7152b171cef312ceb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert correct boundary conditions into system matrix. <br /></td></tr>
<tr class="separator:ac6dc3334b73fd7152b171cef312ceb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac06c286713fa5c53490000fa4fbe55"><td class="memItemLeft" align="right" valign="top"><a id="a8ac06c286713fa5c53490000fa4fbe55"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a8ac06c286713fa5c53490000fa4fbe55">scarc_setup_cmatrix_condensed</a> (NM)</td></tr>
<tr class="memdesc:a8ac06c286713fa5c53490000fa4fbe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup condensed system for compact matrix storage technique. <br /></td></tr>
<tr class="separator:a8ac06c286713fa5c53490000fa4fbe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f818331705900c27abbee2613ba4d25"><td class="memItemLeft" align="right" valign="top"><a id="a1f818331705900c27abbee2613ba4d25"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a1f818331705900c27abbee2613ba4d25">scarc_setup_bmatrix_condensed</a> (NM)</td></tr>
<tr class="memdesc:a1f818331705900c27abbee2613ba4d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup condensed system for bandwise matrix storage technique. <br /></td></tr>
<tr class="separator:a1f818331705900c27abbee2613ba4d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957648f04a57ac876723c14ca5451622"><td class="memItemLeft" align="right" valign="top"><a id="a957648f04a57ac876723c14ca5451622"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a957648f04a57ac876723c14ca5451622">scarc_setup_system_condensed</a> (NV, NL, ITYPE)</td></tr>
<tr class="memdesc:a957648f04a57ac876723c14ca5451622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup condensed system in case of periodic or pure Neumann boundary conditions. <br /></td></tr>
<tr class="separator:a957648f04a57ac876723c14ca5451622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ed753fc5b393c716cc08c4c1bb2b67"><td class="memItemLeft" align="right" valign="top"><a id="ab5ed753fc5b393c716cc08c4c1bb2b67"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab5ed753fc5b393c716cc08c4c1bb2b67">scarc_extract_matrix_overlaps</a> (NMATRIX, NTYPE, NL)</td></tr>
<tr class="memdesc:ab5ed753fc5b393c716cc08c4c1bb2b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract overlapping matrix parts after data exchange with neighbors and add them to main matrix. <br /></td></tr>
<tr class="separator:ab5ed753fc5b393c716cc08c4c1bb2b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825e0e7a73d42f4011e13cba02c72132"><td class="memItemLeft" align="right" valign="top"><a id="a825e0e7a73d42f4011e13cba02c72132"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a825e0e7a73d42f4011e13cba02c72132">scarc_extract_matrix_diagonal</a> (NL)</td></tr>
<tr class="memdesc:a825e0e7a73d42f4011e13cba02c72132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract diagonal of Poisson matrix and store it in a separate vector for further use. <br /></td></tr>
<tr class="separator:a825e0e7a73d42f4011e13cba02c72132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1e7f6613f7ca523eb9d050b958b09c"><td class="memItemLeft" align="right" valign="top"><a id="a1d1e7f6613f7ca523eb9d050b958b09c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a1d1e7f6613f7ca523eb9d050b958b09c">scarc_extract_cell_overlaps</a> (NL)</td></tr>
<tr class="memdesc:a1d1e7f6613f7ca523eb9d050b958b09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract overlapping cell information (including second layers) <br /></td></tr>
<tr class="separator:a1d1e7f6613f7ca523eb9d050b958b09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531b58af7fe0605cb1218fca8af41e9e"><td class="memItemLeft" align="right" valign="top"><a id="a531b58af7fe0605cb1218fca8af41e9e"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a531b58af7fe0605cb1218fca8af41e9e">scarc_extract_zone_overlaps</a> (NL)</td></tr>
<tr class="memdesc:a531b58af7fe0605cb1218fca8af41e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract overlapping zone information (including second layers) <br /></td></tr>
<tr class="separator:a531b58af7fe0605cb1218fca8af41e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addabebd27801d1eeeb54de796e299f22"><td class="memItemLeft" align="right" valign="top"><a id="addabebd27801d1eeeb54de796e299f22"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#addabebd27801d1eeeb54de796e299f22">scarc_extract_zone_pointers</a> (NL)</td></tr>
<tr class="memdesc:addabebd27801d1eeeb54de796e299f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup pointers for overlapping zones for a pair of grid levels. <br /></td></tr>
<tr class="separator:addabebd27801d1eeeb54de796e299f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb91c8cbca13eedcad076c3c0c2d71b0"><td class="memItemLeft" align="right" valign="top"><a id="aeb91c8cbca13eedcad076c3c0c2d71b0"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aeb91c8cbca13eedcad076c3c0c2d71b0">scarc_setup_methods</a></td></tr>
<tr class="memdesc:aeb91c8cbca13eedcad076c3c0c2d71b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup all needed structures for a specified global ScaRC solver. <br /></td></tr>
<tr class="separator:aeb91c8cbca13eedcad076c3c0c2d71b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca60634665a731c105a2fcdf4eae094"><td class="memItemLeft" align="right" valign="top"><a id="abca60634665a731c105a2fcdf4eae094"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#abca60634665a731c105a2fcdf4eae094">scarc_setup_references</a> (BX, BB, BD, BR, BV, BY, BZ, NSTACK)</td></tr>
<tr class="memdesc:abca60634665a731c105a2fcdf4eae094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup references to solution vectors related to used scope (main solver or preconditioner) <br /></td></tr>
<tr class="separator:abca60634665a731c105a2fcdf4eae094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a6e798172fe4ba2a94d44da33e73e1"><td class="memItemLeft" align="right" valign="top"><a id="a31a6e798172fe4ba2a94d44da33e73e1"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a31a6e798172fe4ba2a94d44da33e73e1">scarc_setup_vectors</a> ()</td></tr>
<tr class="memdesc:a31a6e798172fe4ba2a94d44da33e73e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize vectors for Krylov method. <br /></td></tr>
<tr class="separator:a31a6e798172fe4ba2a94d44da33e73e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e86ba90af27e62b141f5f8f0389afc"><td class="memItemLeft" align="right" valign="top"><a id="aa2e86ba90af27e62b141f5f8f0389afc"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aa2e86ba90af27e62b141f5f8f0389afc">scarc_setup_stack</a> (NSTACK)</td></tr>
<tr class="memdesc:aa2e86ba90af27e62b141f5f8f0389afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup environent on specified stack level. <br /></td></tr>
<tr class="separator:aa2e86ba90af27e62b141f5f8f0389afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123d276748e240f68f8cc7187ec72b59"><td class="memItemLeft" align="right" valign="top"><a id="a123d276748e240f68f8cc7187ec72b59"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a123d276748e240f68f8cc7187ec72b59">scarc_restore_stack</a> (NSTACK)</td></tr>
<tr class="memdesc:a123d276748e240f68f8cc7187ec72b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore environent on specified stack level. <br /></td></tr>
<tr class="separator:a123d276748e240f68f8cc7187ec72b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cccbdb97372f46203397e26df6e277c"><td class="memItemLeft" align="right" valign="top"><a id="a4cccbdb97372f46203397e26df6e277c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a4cccbdb97372f46203397e26df6e277c">scarc_setup_krylov</a> (NSOLVER, NSCOPE, NSTAGE, NSTACK, NLMIN, NLMAX)</td></tr>
<tr class="memdesc:a4cccbdb97372f46203397e26df6e277c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize vectors for Krylov method. <br /></td></tr>
<tr class="separator:a4cccbdb97372f46203397e26df6e277c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9038331ca280471bfb5c48f8eee1dda9"><td class="memItemLeft" align="right" valign="top"><a id="a9038331ca280471bfb5c48f8eee1dda9"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a9038331ca280471bfb5c48f8eee1dda9">scarc_setup_multigrid</a> (NSOLVER, NSCOPE, NSTAGE, NSTACK, NLMIN, NLMAX)</td></tr>
<tr class="memdesc:a9038331ca280471bfb5c48f8eee1dda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize vectors for Geometric Multigrid method. <br /></td></tr>
<tr class="separator:a9038331ca280471bfb5c48f8eee1dda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9503ed55c31e3c5beccdb169911a48"><td class="memItemLeft" align="right" valign="top"><a id="a0b9503ed55c31e3c5beccdb169911a48"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a0b9503ed55c31e3c5beccdb169911a48">scarc_setup_coarse_solver</a> (NSTAGE, NSCOPE, NSTACK, NLMIN, NLMAX)</td></tr>
<tr class="memdesc:a0b9503ed55c31e3c5beccdb169911a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize vectors for MKL-methods. <br /></td></tr>
<tr class="separator:a0b9503ed55c31e3c5beccdb169911a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25d83ecc8729a344c0cda32e58bc8b1"><td class="memItemLeft" align="right" valign="top"><a id="aa25d83ecc8729a344c0cda32e58bc8b1"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aa25d83ecc8729a344c0cda32e58bc8b1">scarc_setup_mkl</a> (NSOLVER, NSCOPE, NSTAGE, NSTACK, NLMIN, NLMAX)</td></tr>
<tr class="memdesc:aa25d83ecc8729a344c0cda32e58bc8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize vectors for LU-solvers (based on MKL) <br /></td></tr>
<tr class="separator:aa25d83ecc8729a344c0cda32e58bc8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa59569164c442257010118b742d6b7"><td class="memItemLeft" align="right" valign="top"><a id="a2aa59569164c442257010118b742d6b7"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a2aa59569164c442257010118b742d6b7">scarc_setup_precon</a> (NSTACK, NSCOPE)</td></tr>
<tr class="memdesc:a2aa59569164c442257010118b742d6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize vectors for Krylov method. <br /></td></tr>
<tr class="separator:a2aa59569164c442257010118b742d6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa325f5803548ab87afcbb5ffa92585f9"><td class="memItemLeft" align="right" valign="top"><a id="aa325f5803548ab87afcbb5ffa92585f9"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aa325f5803548ab87afcbb5ffa92585f9">scarc_setup_smooth</a> (NSTACK, NSCOPE)</td></tr>
<tr class="memdesc:aa325f5803548ab87afcbb5ffa92585f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize vectors for Krylov method. <br /></td></tr>
<tr class="separator:aa325f5803548ab87afcbb5ffa92585f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36234566703473ea567564506dee7681"><td class="memItemLeft" align="right" valign="top"><a id="a36234566703473ea567564506dee7681"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a36234566703473ea567564506dee7681">scarc_setup_interpolation</a> (NSTAGE, NLMIN, NLMAX)</td></tr>
<tr class="memdesc:a36234566703473ea567564506dee7681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize vectors for additive or multiplicative coarse grid. <br /></td></tr>
<tr class="separator:a36234566703473ea567564506dee7681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61d8486e0f6e0f16d4e4662fb460025"><td class="memItemLeft" align="right" valign="top"><a id="aa61d8486e0f6e0f16d4e4662fb460025"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aa61d8486e0f6e0f16d4e4662fb460025">scarc_setup_fft</a> (NLMIN, NLMAX)</td></tr>
<tr class="memdesc:aa61d8486e0f6e0f16d4e4662fb460025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup data structures for the use of blockwise FFT methods as preconditioners. <br /></td></tr>
<tr class="separator:aa61d8486e0f6e0f16d4e4662fb460025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b349503c2cc5a2e86ce2814b98ec7b"><td class="memItemLeft" align="right" valign="top"><a id="ab0b349503c2cc5a2e86ce2814b98ec7b"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab0b349503c2cc5a2e86ce2814b98ec7b">scarc_setup_ffto</a> (NLMIN, NLMAX)</td></tr>
<tr class="memdesc:ab0b349503c2cc5a2e86ce2814b98ec7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize vectors for blockwise FFT methods with overlap. <br /></td></tr>
<tr class="separator:ab0b349503c2cc5a2e86ce2814b98ec7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92b9136501658aebf7fbd6273a14cf2"><td class="memItemLeft" align="right" valign="top"><a id="ac92b9136501658aebf7fbd6273a14cf2"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac92b9136501658aebf7fbd6273a14cf2">scarc_setup_mjac</a> (NLMIN, NLMAX)</td></tr>
<tr class="memdesc:ac92b9136501658aebf7fbd6273a14cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store Jacobi preconditioner in matrix form. <br /></td></tr>
<tr class="separator:ac92b9136501658aebf7fbd6273a14cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae401d13a2b43d7826a7c3993b99758fc"><td class="memItemLeft" align="right" valign="top"><a id="ae401d13a2b43d7826a7c3993b99758fc"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae401d13a2b43d7826a7c3993b99758fc">scarc_setup_mgs</a> (NLMIN, NLMAX)</td></tr>
<tr class="memdesc:ae401d13a2b43d7826a7c3993b99758fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store GS preconditioner in matrix form. <br /></td></tr>
<tr class="separator:ae401d13a2b43d7826a7c3993b99758fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a50257b4f95b30e8444edc203a630e"><td class="memItemLeft" align="right" valign="top"><a id="ab7a50257b4f95b30e8444edc203a630e"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab7a50257b4f95b30e8444edc203a630e">scarc_setup_msgs</a> (NLMIN, NLMAX)</td></tr>
<tr class="memdesc:ab7a50257b4f95b30e8444edc203a630e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store symmetric Gauss-Seidel preconditioner in matrix form. <br /></td></tr>
<tr class="separator:ab7a50257b4f95b30e8444edc203a630e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3423c2be947e0e7e04bef0556ade0dc"><td class="memItemLeft" align="right" valign="top"><a id="ad3423c2be947e0e7e04bef0556ade0dc"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ad3423c2be947e0e7e04bef0556ade0dc">scarc_setup_msor</a> (NLMIN, NLMAX, NSTACK)</td></tr>
<tr class="memdesc:ad3423c2be947e0e7e04bef0556ade0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store SOR preconditioner in matrix form. <br /></td></tr>
<tr class="separator:ad3423c2be947e0e7e04bef0556ade0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b13e5dbdddb0a5a79c5a2cebc42632"><td class="memItemLeft" align="right" valign="top"><a id="a89b13e5dbdddb0a5a79c5a2cebc42632"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a89b13e5dbdddb0a5a79c5a2cebc42632">scarc_setup_mssor</a> (NLMIN, NLMAX, NSTACK)</td></tr>
<tr class="memdesc:a89b13e5dbdddb0a5a79c5a2cebc42632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store SSOR preconditioner in matrix form. <br /></td></tr>
<tr class="separator:a89b13e5dbdddb0a5a79c5a2cebc42632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ca389f865022b6f48c79943d4767fe"><td class="memItemLeft" align="right" valign="top"><a id="ad4ca389f865022b6f48c79943d4767fe"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ad4ca389f865022b6f48c79943d4767fe">scarc_setup_ilu</a> (NLMIN, NLMAX)</td></tr>
<tr class="memdesc:ad4ca389f865022b6f48c79943d4767fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize ILU(0) decomposition of Poisson matrix. <br /></td></tr>
<tr class="separator:ad4ca389f865022b6f48c79943d4767fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44dd20ab5ab70f606bb8ac5dfdea01d3"><td class="memItemLeft" align="right" valign="top"><a id="a44dd20ab5ab70f606bb8ac5dfdea01d3"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a44dd20ab5ab70f606bb8ac5dfdea01d3">scarc_setup_cluster</a> (NLMIN, NLMAX)</td></tr>
<tr class="memdesc:a44dd20ab5ab70f606bb8ac5dfdea01d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize CLUSTER_SPARSE_SOLVER from MKL-library. <br /></td></tr>
<tr class="separator:a44dd20ab5ab70f606bb8ac5dfdea01d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae929d4f46798b0971f7469f17a690859"><td class="memItemLeft" align="right" valign="top"><a id="ae929d4f46798b0971f7469f17a690859"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae929d4f46798b0971f7469f17a690859">scarc_setup_pardiso</a> (NLMIN, NLMAX)</td></tr>
<tr class="memdesc:ae929d4f46798b0971f7469f17a690859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize PARDISO solver from MKL-library. <br /></td></tr>
<tr class="separator:ae929d4f46798b0971f7469f17a690859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a21819d5feb02474f29bd12e8a55e9"><td class="memItemLeft" align="right" valign="top"><a id="a42a21819d5feb02474f29bd12e8a55e9"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a42a21819d5feb02474f29bd12e8a55e9">scarc_setup_poisson_sizes</a> (NL)</td></tr>
<tr class="memdesc:a42a21819d5feb02474f29bd12e8a55e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define sizes for system matrix A (including extended regions related to overlaps) <br /></td></tr>
<tr class="separator:a42a21819d5feb02474f29bd12e8a55e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6032580720016fe9fa04da3f0df5b3cc"><td class="memItemLeft" align="right" valign="top"><a id="a6032580720016fe9fa04da3f0df5b3cc"></a>
subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a6032580720016fe9fa04da3f0df5b3cc">scarc_solver</a> (DT_CURRENT)</td></tr>
<tr class="memdesc:a6032580720016fe9fa04da3f0df5b3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic call of ScaRC solver routine. <br /></td></tr>
<tr class="separator:a6032580720016fe9fa04da3f0df5b3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e416171ae0b9cb8b2aad9d481df4ce"><td class="memItemLeft" align="right" valign="top"><a id="a95e416171ae0b9cb8b2aad9d481df4ce"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a95e416171ae0b9cb8b2aad9d481df4ce">scarc_method_fft</a></td></tr>
<tr class="memdesc:a95e416171ae0b9cb8b2aad9d481df4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform preceding FFT method to improve start solution for ScaRC. <br /></td></tr>
<tr class="separator:a95e416171ae0b9cb8b2aad9d481df4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f4c94bfaeddd5cdf95bfa67613f5c7"><td class="memItemLeft" align="right" valign="top"><a id="a68f4c94bfaeddd5cdf95bfa67613f5c7"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a68f4c94bfaeddd5cdf95bfa67613f5c7">scarc_matvec_product</a> (NV1, NV2, NL)</td></tr>
<tr class="memdesc:a68f4c94bfaeddd5cdf95bfa67613f5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute global matrix-vector product A*x = y on grid level NL. <br /></td></tr>
<tr class="separator:a68f4c94bfaeddd5cdf95bfa67613f5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c02948ed80418b9e2e21b82ae063a3"><td class="memItemLeft" align="right" valign="top"><a id="ab5c02948ed80418b9e2e21b82ae063a3"></a>
real(eb) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab5c02948ed80418b9e2e21b82ae063a3">scarc_scalar_product</a> (NV1, NV2, NL)</td></tr>
<tr class="memdesc:ab5c02948ed80418b9e2e21b82ae063a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute global scalar-product including global data exchange. <br /></td></tr>
<tr class="separator:ab5c02948ed80418b9e2e21b82ae063a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3eab947ac38c379925aae68605ec3e9"><td class="memItemLeft" align="right" valign="top"><a id="ae3eab947ac38c379925aae68605ec3e9"></a>
real(eb) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae3eab947ac38c379925aae68605ec3e9">scarc_l2norm</a> (NV1, NL)</td></tr>
<tr class="memdesc:ae3eab947ac38c379925aae68605ec3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute global L2-norm including global data exchange. <br /></td></tr>
<tr class="separator:ae3eab947ac38c379925aae68605ec3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d058b44fafd1bff901dcf10f4edbb79"><td class="memItemLeft" align="right" valign="top"><a id="a5d058b44fafd1bff901dcf10f4edbb79"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a5d058b44fafd1bff901dcf10f4edbb79">scarc_vector_sum</a> (NV1, NV2, SCAL1, SCAL2, NL)</td></tr>
<tr class="memdesc:a5d058b44fafd1bff901dcf10f4edbb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute linear combination of two vectors for bandwise storage technique. <br /></td></tr>
<tr class="separator:a5d058b44fafd1bff901dcf10f4edbb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec7733e8344441086f79467cd9f2731"><td class="memItemLeft" align="right" valign="top"><a id="a1ec7733e8344441086f79467cd9f2731"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a1ec7733e8344441086f79467cd9f2731">scarc_vector_copy</a> (NV1, NV2, SCAL1, NL)</td></tr>
<tr class="memdesc:a1ec7733e8344441086f79467cd9f2731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define vector2 to be a scaled copy of vector 1. <br /></td></tr>
<tr class="separator:a1ec7733e8344441086f79467cd9f2731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b3b973f38d2c883ee582a4658798df"><td class="memItemLeft" align="right" valign="top"><a id="a91b3b973f38d2c883ee582a4658798df"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a91b3b973f38d2c883ee582a4658798df">scarc_vector_clear</a> (NV, NL)</td></tr>
<tr class="memdesc:a91b3b973f38d2c883ee582a4658798df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear vector. <br /></td></tr>
<tr class="separator:a91b3b973f38d2c883ee582a4658798df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7724638fc0f2350f81c8b79ebab4653"><td class="memItemLeft" align="right" valign="top"><a id="ac7724638fc0f2350f81c8b79ebab4653"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac7724638fc0f2350f81c8b79ebab4653">scarc_vector_random_init</a> (NV, NL)</td></tr>
<tr class="memdesc:ac7724638fc0f2350f81c8b79ebab4653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preset vector with specified value. <br /></td></tr>
<tr class="separator:ac7724638fc0f2350f81c8b79ebab4653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa45afcd4956c08b03406ba95a8099f"><td class="memItemLeft" align="right" valign="top"><a id="aeaa45afcd4956c08b03406ba95a8099f"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aeaa45afcd4956c08b03406ba95a8099f">scarc_vector_init</a> (NV, VAL, NL)</td></tr>
<tr class="memdesc:aeaa45afcd4956c08b03406ba95a8099f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preset vector with specified value. <br /></td></tr>
<tr class="separator:aeaa45afcd4956c08b03406ba95a8099f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae705fe5d4fa1b5aa6161c17b9a976d38"><td class="memItemLeft" align="right" valign="top"><a id="ae705fe5d4fa1b5aa6161c17b9a976d38"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae705fe5d4fa1b5aa6161c17b9a976d38">scarc_relaxation</a> (NV1, NV2, NS, NP, NL)</td></tr>
<tr class="memdesc:ae705fe5d4fa1b5aa6161c17b9a976d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform preconditioning based on requested local solvers. <br /></td></tr>
<tr class="separator:ae705fe5d4fa1b5aa6161c17b9a976d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad21156934419cf0a26e234acbb846a4"><td class="memItemLeft" align="right" valign="top"><a id="aad21156934419cf0a26e234acbb846a4"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aad21156934419cf0a26e234acbb846a4">scarc_method_cluster</a> (NSTACK, NPARENT, NLEVEL)</td></tr>
<tr class="memdesc:aad21156934419cf0a26e234acbb846a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform global Pardiso-method based on MKL. <br /></td></tr>
<tr class="separator:aad21156934419cf0a26e234acbb846a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf677eeb9bb6a1bc2b527e9c66f5bc3a"><td class="memItemLeft" align="right" valign="top"><a id="adf677eeb9bb6a1bc2b527e9c66f5bc3a"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#adf677eeb9bb6a1bc2b527e9c66f5bc3a">scarc_method_pardiso</a> (NSTACK, NPARENT, NLEVEL)</td></tr>
<tr class="memdesc:adf677eeb9bb6a1bc2b527e9c66f5bc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform global Pardiso-method based on MKL. <br /></td></tr>
<tr class="separator:adf677eeb9bb6a1bc2b527e9c66f5bc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3bc9fbcad2e96d93bf226dad0beffb"><td class="memItemLeft" align="right" valign="top"><a id="aaf3bc9fbcad2e96d93bf226dad0beffb"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aaf3bc9fbcad2e96d93bf226dad0beffb">scarc_increase_iteration_counts</a> (ITE0)</td></tr>
<tr class="memdesc:aaf3bc9fbcad2e96d93bf226dad0beffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase corresponding iteration count (just for visualization of convergence behavior) <br /></td></tr>
<tr class="separator:aaf3bc9fbcad2e96d93bf226dad0beffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af442dd90741d10ca34a3896f74a247ae"><td class="memItemLeft" align="right" valign="top"><a id="af442dd90741d10ca34a3896f74a247ae"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#af442dd90741d10ca34a3896f74a247ae">scarc_method_cg</a> (NSTACK, NPARENT, NRHS, NLEVEL)</td></tr>
<tr class="memdesc:af442dd90741d10ca34a3896f74a247ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform global conjugate gradient method based on global Possion-matrix. <br /></td></tr>
<tr class="separator:af442dd90741d10ca34a3896f74a247ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d7567e863c768491b54bcb55d66e06"><td class="memItemLeft" align="right" valign="top"><a id="a37d7567e863c768491b54bcb55d66e06"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a37d7567e863c768491b54bcb55d66e06">scarc_preconditioner</a> (NS, NP, NL)</td></tr>
<tr class="memdesc:a37d7567e863c768491b54bcb55d66e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preconditioning method which is based on the following input and output convention: <br /></td></tr>
<tr class="separator:a37d7567e863c768491b54bcb55d66e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8152b0a273de016258c341f2c0c179"><td class="memItemLeft" align="right" valign="top"><a id="a3e8152b0a273de016258c341f2c0c179"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a3e8152b0a273de016258c341f2c0c179">scarc_method_coarse</a> (NSTACK, NPARENT, NLEVEL)</td></tr>
<tr class="memdesc:a3e8152b0a273de016258c341f2c0c179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform requested coarse grid solver (iterative/direct) <br /></td></tr>
<tr class="separator:a3e8152b0a273de016258c341f2c0c179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3712210d92136ae472f564ae6d33ec1"><td class="memItemLeft" align="right" valign="top"><a id="ad3712210d92136ae472f564ae6d33ec1"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ad3712210d92136ae472f564ae6d33ec1">scarc_method_multigrid</a> (NSTACK, NPARENT, NRHS, NLEVEL)</td></tr>
<tr class="memdesc:ad3712210d92136ae472f564ae6d33ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform geometric multigrid method based on global possion-matrix. <br /></td></tr>
<tr class="separator:ad3712210d92136ae472f564ae6d33ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d1778e865d320607e450a0078a3859"><td class="memItemLeft" align="right" valign="top"><a id="ae4d1778e865d320607e450a0078a3859"></a>
integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae4d1778e865d320607e450a0078a3859">scarc_cycling_control</a> (NTYPE, NL)</td></tr>
<tr class="memdesc:ae4d1778e865d320607e450a0078a3859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control multigrid cycling (F/V/W) <br /></td></tr>
<tr class="separator:ae4d1778e865d320607e450a0078a3859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e3d43c84d786d9e1b09071ee662f96"><td class="memItemLeft" align="right" valign="top"><a id="a74e3d43c84d786d9e1b09071ee662f96"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a74e3d43c84d786d9e1b09071ee662f96">scarc_smoother</a> (NTYPE, NSTACK, NPARENT, NLEVEL)</td></tr>
<tr class="memdesc:a74e3d43c84d786d9e1b09071ee662f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform smoothing based on specified relaxation method. <br /></td></tr>
<tr class="separator:a74e3d43c84d786d9e1b09071ee662f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bacd78bdaf1c5c3226e3963aa89c896"><td class="memItemLeft" align="right" valign="top"><a id="a6bacd78bdaf1c5c3226e3963aa89c896"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a6bacd78bdaf1c5c3226e3963aa89c896">scarc_setup_solver</a> (NS, NP)</td></tr>
<tr class="memdesc:a6bacd78bdaf1c5c3226e3963aa89c896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup environement for current solver. <br /></td></tr>
<tr class="separator:a6bacd78bdaf1c5c3226e3963aa89c896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c8fb0df88b18c40d1c6055bb7aa9d2"><td class="memItemLeft" align="right" valign="top"><a id="ad5c8fb0df88b18c40d1c6055bb7aa9d2"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ad5c8fb0df88b18c40d1c6055bb7aa9d2">scarc_release_solver</a> (NS, NP)</td></tr>
<tr class="memdesc:ad5c8fb0df88b18c40d1c6055bb7aa9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset environment of calling routine when leaving solver. <br /></td></tr>
<tr class="separator:ad5c8fb0df88b18c40d1c6055bb7aa9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119d30330d1a179932f6dab3eceab010"><td class="memItemLeft" align="right" valign="top"><a id="a119d30330d1a179932f6dab3eceab010"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a119d30330d1a179932f6dab3eceab010">scarc_setup_workspace</a> (NS, NL, NRHS)</td></tr>
<tr class="memdesc:a119d30330d1a179932f6dab3eceab010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set initial solution corresponding to boundary data in BXS, BXF, ... <br /></td></tr>
<tr class="separator:a119d30330d1a179932f6dab3eceab010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae46b3d2d5b1a0cdd95f0ffd9f7cd48a"><td class="memItemLeft" align="right" valign="top"><a id="aae46b3d2d5b1a0cdd95f0ffd9f7cd48a"></a>
integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aae46b3d2d5b1a0cdd95f0ffd9f7cd48a">scarc_convergence_state</a> (ISM, NS, NL)</td></tr>
<tr class="memdesc:aae46b3d2d5b1a0cdd95f0ffd9f7cd48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if solver converges or diverges and print out residual information. <br /></td></tr>
<tr class="separator:aae46b3d2d5b1a0cdd95f0ffd9f7cd48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b350ad437fcdb07052e67f2ec58a3ea"><td class="memItemLeft" align="right" valign="top"><a id="a7b350ad437fcdb07052e67f2ec58a3ea"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a7b350ad437fcdb07052e67f2ec58a3ea">scarc_convergence_rate</a> (NSTATE, NS, NL)</td></tr>
<tr class="memdesc:a7b350ad437fcdb07052e67f2ec58a3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute convergence rate and print out residual information for final loop. <br /></td></tr>
<tr class="separator:a7b350ad437fcdb07052e67f2ec58a3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27432ab353a68234bb7a378cc68d734d"><td class="memItemLeft" align="right" valign="top"><a id="a27432ab353a68234bb7a378cc68d734d"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a27432ab353a68234bb7a378cc68d734d">scarc_restriction</a> (NVB, NVC, NLF, NLC)</td></tr>
<tr class="memdesc:a27432ab353a68234bb7a378cc68d734d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform restriction from finer to coarser grid level. <br /></td></tr>
<tr class="separator:a27432ab353a68234bb7a378cc68d734d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972ca87dc328530c21bfe0edb3e25f12"><td class="memItemLeft" align="right" valign="top"><a id="a972ca87dc328530c21bfe0edb3e25f12"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a972ca87dc328530c21bfe0edb3e25f12">scarc_prolongation</a> (NVC, NVB, NLC, NLF)</td></tr>
<tr class="memdesc:a972ca87dc328530c21bfe0edb3e25f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform prolongation from coarser to finer grid level. <br /></td></tr>
<tr class="separator:a972ca87dc328530c21bfe0edb3e25f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec56420f03146dbccb343b2c77428ac4"><td class="memItemLeft" align="right" valign="top"><a id="aec56420f03146dbccb343b2c77428ac4"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aec56420f03146dbccb343b2c77428ac4">scarc_update_preconditioner</a> (NL)</td></tr>
<tr class="memdesc:aec56420f03146dbccb343b2c77428ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy final solution from GMG (as preconditioner) to corresponding vector of CG (as main solver) <br /></td></tr>
<tr class="separator:aec56420f03146dbccb343b2c77428ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2ecb959e4f298d922c89fa66ab5a35"><td class="memItemLeft" align="right" valign="top"><a id="a6e2ecb959e4f298d922c89fa66ab5a35"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a6e2ecb959e4f298d922c89fa66ab5a35">scarc_update_maincells</a> (NL)</td></tr>
<tr class="memdesc:a6e2ecb959e4f298d922c89fa66ab5a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize data for pressure vector (predictor/corrector) when local ScaRC solver has finished. <br /></td></tr>
<tr class="separator:a6e2ecb959e4f298d922c89fa66ab5a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc29c459979a0688a49272d661cec31a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#abc29c459979a0688a49272d661cec31a">scarc_update_ghostcells</a> (NL)</td></tr>
<tr class="memdesc:abc29c459979a0688a49272d661cec31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set correct boundary values at external and internal boundaries.  <a href="namespacescrc.html#abc29c459979a0688a49272d661cec31a">More...</a><br /></td></tr>
<tr class="separator:abc29c459979a0688a49272d661cec31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12bae9631dbd0bdfd66d66515e4525f"><td class="memItemLeft" align="right" valign="top"><a id="ae12bae9631dbd0bdfd66d66515e4525f"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae12bae9631dbd0bdfd66d66515e4525f">scarc_exchange</a> (NTYPE, NPARAM, NL)</td></tr>
<tr class="memdesc:ae12bae9631dbd0bdfd66d66515e4525f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform data exchange corresponding to requested exchange type. <br /></td></tr>
<tr class="separator:ae12bae9631dbd0bdfd66d66515e4525f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6faca9453be185210b0a288a14e8764"><td class="memItemLeft" align="right" valign="top"><a id="ab6faca9453be185210b0a288a14e8764"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab6faca9453be185210b0a288a14e8764">scarc_recv_message_int</a> (NM, NOM, NL, NTYPE, CTEXT)</td></tr>
<tr class="memdesc:ab6faca9453be185210b0a288a14e8764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data of type integer. <br /></td></tr>
<tr class="separator:ab6faca9453be185210b0a288a14e8764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43da1b72820d2a132a08551d53eb5ef3"><td class="memItemLeft" align="right" valign="top"><a id="a43da1b72820d2a132a08551d53eb5ef3"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a43da1b72820d2a132a08551d53eb5ef3">scarc_recv_message_real</a> (NM, NOM, NL, NTYPE, CTEXT)</td></tr>
<tr class="memdesc:a43da1b72820d2a132a08551d53eb5ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data of type real. <br /></td></tr>
<tr class="separator:a43da1b72820d2a132a08551d53eb5ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cb0df4ea4ca75d1311544f4b69926f"><td class="memItemLeft" align="right" valign="top"><a id="a31cb0df4ea4ca75d1311544f4b69926f"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a31cb0df4ea4ca75d1311544f4b69926f">scarc_send_message_int</a> (NM, NOM, NL, NTYPE, CTEXT)</td></tr>
<tr class="memdesc:a31cb0df4ea4ca75d1311544f4b69926f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data of integer type. <br /></td></tr>
<tr class="separator:a31cb0df4ea4ca75d1311544f4b69926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f0c30eaf6c792817f4895e71bdce12"><td class="memItemLeft" align="right" valign="top"><a id="aa6f0c30eaf6c792817f4895e71bdce12"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aa6f0c30eaf6c792817f4895e71bdce12">scarc_send_message_real</a> (NM, NOM, NL, NTYPE, CTEXT)</td></tr>
<tr class="memdesc:aa6f0c30eaf6c792817f4895e71bdce12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data of real type. <br /></td></tr>
<tr class="separator:aa6f0c30eaf6c792817f4895e71bdce12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc91ce9824b07277f97b572e9aad54c"><td class="memItemLeft" align="right" valign="top"><a id="adcc91ce9824b07277f97b572e9aad54c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#adcc91ce9824b07277f97b572e9aad54c">scarc_pack_cell_numbers</a></td></tr>
<tr class="memdesc:adcc91ce9824b07277f97b572e9aad54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack numbers of cells which are overlapped by neighbor. <br /></td></tr>
<tr class="separator:adcc91ce9824b07277f97b572e9aad54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f55c01c8ce5b44fa70b22e551a30459"><td class="memItemLeft" align="right" valign="top"><a id="a4f55c01c8ce5b44fa70b22e551a30459"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a4f55c01c8ce5b44fa70b22e551a30459">scarc_unpack_cell_numbers</a> (NM, NOM)</td></tr>
<tr class="memdesc:a4f55c01c8ce5b44fa70b22e551a30459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack numbers of cells which are overlapped by neighbor. <br /></td></tr>
<tr class="separator:a4f55c01c8ce5b44fa70b22e551a30459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5117362a78cd2218685524f78089f3"><td class="memItemLeft" align="right" valign="top"><a id="a8d5117362a78cd2218685524f78089f3"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a8d5117362a78cd2218685524f78089f3">scarc_pack_cell_sizes</a></td></tr>
<tr class="memdesc:a8d5117362a78cd2218685524f78089f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack cell width information. <br /></td></tr>
<tr class="separator:a8d5117362a78cd2218685524f78089f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f8d325f97e247947e8eb7d876eb767"><td class="memItemLeft" align="right" valign="top"><a id="a40f8d325f97e247947e8eb7d876eb767"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a40f8d325f97e247947e8eb7d876eb767">scarc_unpack_cell_sizes</a> (NM, NOM)</td></tr>
<tr class="memdesc:a40f8d325f97e247947e8eb7d876eb767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack cell width information. <br /></td></tr>
<tr class="separator:a40f8d325f97e247947e8eb7d876eb767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef70cb19f687ad45724bc922a7147b0"><td class="memItemLeft" align="right" valign="top"><a id="a7ef70cb19f687ad45724bc922a7147b0"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a7ef70cb19f687ad45724bc922a7147b0">scarc_pack_basic_sizes</a></td></tr>
<tr class="memdesc:a7ef70cb19f687ad45724bc922a7147b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack initial exchange sizes along interfaces. <br /></td></tr>
<tr class="separator:a7ef70cb19f687ad45724bc922a7147b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2883d92dcb27689af186babc7de58c1"><td class="memItemLeft" align="right" valign="top"><a id="af2883d92dcb27689af186babc7de58c1"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#af2883d92dcb27689af186babc7de58c1">scarc_unpack_basic_sizes</a> (NM, NOM)</td></tr>
<tr class="memdesc:af2883d92dcb27689af186babc7de58c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack initial exchange sizes along interfaces. <br /></td></tr>
<tr class="separator:af2883d92dcb27689af186babc7de58c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6ef4510d7862161207fe18935b55ad"><td class="memItemLeft" align="right" valign="top"><a id="ade6ef4510d7862161207fe18935b55ad"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ade6ef4510d7862161207fe18935b55ad">scarc_pack_pressure</a> (NM)</td></tr>
<tr class="memdesc:ade6ef4510d7862161207fe18935b55ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack overlapping parts of specified pressure vector (predictor/corrector) <br /></td></tr>
<tr class="separator:ade6ef4510d7862161207fe18935b55ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6116bc77def2557a830dca6f1ace4ccf"><td class="memItemLeft" align="right" valign="top"><a id="a6116bc77def2557a830dca6f1ace4ccf"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a6116bc77def2557a830dca6f1ace4ccf">scarc_unpack_pressure</a> (NM, NOM)</td></tr>
<tr class="memdesc:a6116bc77def2557a830dca6f1ace4ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack overlapping parts of specified pressure vector (predictor/corrector) <br /></td></tr>
<tr class="separator:a6116bc77def2557a830dca6f1ace4ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd659a90889497c1241af93b230f6353"><td class="memItemLeft" align="right" valign="top"><a id="acd659a90889497c1241af93b230f6353"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#acd659a90889497c1241af93b230f6353">scarc_pack_auxiliary</a></td></tr>
<tr class="memdesc:acd659a90889497c1241af93b230f6353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack overlapping auxiliary vector. <br /></td></tr>
<tr class="separator:acd659a90889497c1241af93b230f6353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c0c484f74bd0162ac51042767a7a3c"><td class="memItemLeft" align="right" valign="top"><a id="a88c0c484f74bd0162ac51042767a7a3c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a88c0c484f74bd0162ac51042767a7a3c">scarc_unpack_auxiliary</a> (NM, NOM)</td></tr>
<tr class="memdesc:a88c0c484f74bd0162ac51042767a7a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack overlapping auxiliary vector. <br /></td></tr>
<tr class="separator:a88c0c484f74bd0162ac51042767a7a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8213e19e4fc511a7cd32ad1cebdabd"><td class="memItemLeft" align="right" valign="top"><a id="a6b8213e19e4fc511a7cd32ad1cebdabd"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a6b8213e19e4fc511a7cd32ad1cebdabd">scarc_pack_nullspace</a></td></tr>
<tr class="memdesc:a6b8213e19e4fc511a7cd32ad1cebdabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack and unpack overlapping nullspace vector. <br /></td></tr>
<tr class="separator:a6b8213e19e4fc511a7cd32ad1cebdabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299a115aaa5550f9a2e0d67e32c5f99a"><td class="memItemLeft" align="right" valign="top"><a id="a299a115aaa5550f9a2e0d67e32c5f99a"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a299a115aaa5550f9a2e0d67e32c5f99a">scarc_unpack_nullspace</a> (NM, NOM)</td></tr>
<tr class="memdesc:a299a115aaa5550f9a2e0d67e32c5f99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack overlapping nullspace vector. <br /></td></tr>
<tr class="separator:a299a115aaa5550f9a2e0d67e32c5f99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7bba07202c9fde28ac34b4eb7ce934"><td class="memItemLeft" align="right" valign="top"><a id="abc7bba07202c9fde28ac34b4eb7ce934"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#abc7bba07202c9fde28ac34b4eb7ce934">scarc_pack_vector_plain</a> (NM, NL, NV)</td></tr>
<tr class="memdesc:abc7bba07202c9fde28ac34b4eb7ce934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack overlapping parts of specified vector VC (numbered via IC values) <br /></td></tr>
<tr class="separator:abc7bba07202c9fde28ac34b4eb7ce934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4a656ef43d8271a4757bb982637e9a"><td class="memItemLeft" align="right" valign="top"><a id="aff4a656ef43d8271a4757bb982637e9a"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aff4a656ef43d8271a4757bb982637e9a">scarc_unpack_vector_plain</a> (NM, NOM, NL, NVECTOR)</td></tr>
<tr class="memdesc:aff4a656ef43d8271a4757bb982637e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack overlapping parts of specified vector VC (numbered via IC values) <br /></td></tr>
<tr class="separator:aff4a656ef43d8271a4757bb982637e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeac03e2e1cb1844a6eca46b64ca75c4"><td class="memItemLeft" align="right" valign="top"><a id="aaeac03e2e1cb1844a6eca46b64ca75c4"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aaeac03e2e1cb1844a6eca46b64ca75c4">scarc_pack_vector_mean</a> (NM, NL, NVECTOR)</td></tr>
<tr class="memdesc:aaeac03e2e1cb1844a6eca46b64ca75c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack overlapping and internal parts of specified vector. <br /></td></tr>
<tr class="separator:aaeac03e2e1cb1844a6eca46b64ca75c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16a9e91864bd40f13ac85c611126bf7"><td class="memItemLeft" align="right" valign="top"><a id="af16a9e91864bd40f13ac85c611126bf7"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#af16a9e91864bd40f13ac85c611126bf7">scarc_unpack_vector_mean</a> (NM, NOM, NL, NVECTOR)</td></tr>
<tr class="memdesc:af16a9e91864bd40f13ac85c611126bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack overlapping and internal parts of specified vector. <br /></td></tr>
<tr class="separator:af16a9e91864bd40f13ac85c611126bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2514a7abc4a46eac6d7039e6eda935"><td class="memItemLeft" align="right" valign="top"><a id="afe2514a7abc4a46eac6d7039e6eda935"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#afe2514a7abc4a46eac6d7039e6eda935">scarc_pack_poisson_cols</a> (NM, NMATRIX)</td></tr>
<tr class="memdesc:afe2514a7abc4a46eac6d7039e6eda935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack overlapping information about matrix columns (compact storage technique only) <br /></td></tr>
<tr class="separator:afe2514a7abc4a46eac6d7039e6eda935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bee92ca2545ae241246e8634c387c4"><td class="memItemLeft" align="right" valign="top"><a id="a90bee92ca2545ae241246e8634c387c4"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a90bee92ca2545ae241246e8634c387c4">scarc_unpack_poisson_cols</a> (NM, NOM, NMATRIX)</td></tr>
<tr class="memdesc:a90bee92ca2545ae241246e8634c387c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack overlapping information about matrix columns (compact storage technique only) <br /></td></tr>
<tr class="separator:a90bee92ca2545ae241246e8634c387c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6131f271338017ce577f8d5e8ed36181"><td class="memItemLeft" align="right" valign="top"><a id="a6131f271338017ce577f8d5e8ed36181"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a6131f271338017ce577f8d5e8ed36181">scarc_pack_poisson_colsg</a> (NM, NMATRIX)</td></tr>
<tr class="memdesc:a6131f271338017ce577f8d5e8ed36181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack overlapping information about matrix columns (compact storage technique only) <br /></td></tr>
<tr class="separator:a6131f271338017ce577f8d5e8ed36181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3569a9cdfbeaa77a2f1170bd8e9e0f8b"><td class="memItemLeft" align="right" valign="top"><a id="a3569a9cdfbeaa77a2f1170bd8e9e0f8b"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a3569a9cdfbeaa77a2f1170bd8e9e0f8b">scarc_unpack_poisson_colsg</a> (NM, NOM, NMATRIX)</td></tr>
<tr class="memdesc:a3569a9cdfbeaa77a2f1170bd8e9e0f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack overlapping information about matrix columns (compact storage technique only) <br /></td></tr>
<tr class="separator:a3569a9cdfbeaa77a2f1170bd8e9e0f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c389804f18524864d719902b2694ed"><td class="memItemLeft" align="right" valign="top"><a id="a89c389804f18524864d719902b2694ed"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a89c389804f18524864d719902b2694ed">scarc_pack_poisson_vals</a> (NMATRIX, NL)</td></tr>
<tr class="memdesc:a89c389804f18524864d719902b2694ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack overlapping information about matrix values (both storage techniques) <br /></td></tr>
<tr class="separator:a89c389804f18524864d719902b2694ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06dd732f191f5e323d502031473441cf"><td class="memItemLeft" align="right" valign="top"><a id="a06dd732f191f5e323d502031473441cf"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a06dd732f191f5e323d502031473441cf">scarc_unpack_poisson_vals</a> (NM, NOM, NL, NMATRIX)</td></tr>
<tr class="memdesc:a06dd732f191f5e323d502031473441cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack overlapping information about matrix values (both storage techniques) <br /></td></tr>
<tr class="separator:a06dd732f191f5e323d502031473441cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c26ecf4474d95408c36e87e98563829"><td class="memItemLeft" align="right" valign="top"><a id="a0c26ecf4474d95408c36e87e98563829"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a0c26ecf4474d95408c36e87e98563829">scarc_pack_poisson_sizes</a> (NL)</td></tr>
<tr class="memdesc:a0c26ecf4474d95408c36e87e98563829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack information about matrix sizes into send vector. <br /></td></tr>
<tr class="separator:a0c26ecf4474d95408c36e87e98563829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf4c695d86ffc61c52437623fbf957e"><td class="memItemLeft" align="right" valign="top"><a id="abaf4c695d86ffc61c52437623fbf957e"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#abaf4c695d86ffc61c52437623fbf957e">scarc_unpack_poisson_sizes</a> (NM, NOM, NL)</td></tr>
<tr class="memdesc:abaf4c695d86ffc61c52437623fbf957e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack information about matrix sizes into send vector. <br /></td></tr>
<tr class="separator:abaf4c695d86ffc61c52437623fbf957e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fa687730486042815137c699572bd2"><td class="memItemLeft" align="right" valign="top"><a id="ac5fa687730486042815137c699572bd2"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac5fa687730486042815137c699572bd2">scarc_pack_poisson_diags</a> (NTYPE)</td></tr>
<tr class="memdesc:ac5fa687730486042815137c699572bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack overlapping information about matrix diagonals (compact storage technique only) <br /></td></tr>
<tr class="separator:ac5fa687730486042815137c699572bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af787ac406d4088abf29a011cf65c2e34"><td class="memItemLeft" align="right" valign="top"><a id="af787ac406d4088abf29a011cf65c2e34"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#af787ac406d4088abf29a011cf65c2e34">scarc_unpack_poisson_diags</a> (NM, NOM)</td></tr>
<tr class="memdesc:af787ac406d4088abf29a011cf65c2e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack overlapping information about matrix diagonals (compact storage technique only) <br /></td></tr>
<tr class="separator:af787ac406d4088abf29a011cf65c2e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db9333c6bb1d63d4dd12d997215b109"><td class="memItemLeft" align="right" valign="top"><a id="a3db9333c6bb1d63d4dd12d997215b109"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a3db9333c6bb1d63d4dd12d997215b109">scarc_pack_cell_neighbors</a> (NM)</td></tr>
<tr class="memdesc:a3db9333c6bb1d63d4dd12d997215b109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack zones numbers along interfaces. <br /></td></tr>
<tr class="separator:a3db9333c6bb1d63d4dd12d997215b109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e46c62e146662b83a6c3d0e9925d99"><td class="memItemLeft" align="right" valign="top"><a id="ac6e46c62e146662b83a6c3d0e9925d99"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac6e46c62e146662b83a6c3d0e9925d99">scarc_unpack_cell_neighbors</a> (NM, NOM)</td></tr>
<tr class="memdesc:ac6e46c62e146662b83a6c3d0e9925d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack zones numbers along interfaces. <br /></td></tr>
<tr class="separator:ac6e46c62e146662b83a6c3d0e9925d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21261bf01e5557f847d2481ab935f83"><td class="memItemLeft" align="right" valign="top"><a id="ab21261bf01e5557f847d2481ab935f83"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab21261bf01e5557f847d2481ab935f83">scarc_pack_zone_neighbors</a> (NM)</td></tr>
<tr class="memdesc:ab21261bf01e5557f847d2481ab935f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack zones numbers along interfaces. <br /></td></tr>
<tr class="separator:ab21261bf01e5557f847d2481ab935f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e2ff2d473284d13c96b381f9253953"><td class="memItemLeft" align="right" valign="top"><a id="ab6e2ff2d473284d13c96b381f9253953"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab6e2ff2d473284d13c96b381f9253953">scarc_unpack_zone_neighbors</a> (NM, NOM)</td></tr>
<tr class="memdesc:ab6e2ff2d473284d13c96b381f9253953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack zones numbers along interfaces. <br /></td></tr>
<tr class="separator:ab6e2ff2d473284d13c96b381f9253953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ef9caa6cce3d62f088cd50f9b88b45"><td class="memItemLeft" align="right" valign="top"><a id="ae5ef9caa6cce3d62f088cd50f9b88b45"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae5ef9caa6cce3d62f088cd50f9b88b45">scarc_pack_zone_types</a> (NM)</td></tr>
<tr class="memdesc:ae5ef9caa6cce3d62f088cd50f9b88b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack zones information into send vector. <br /></td></tr>
<tr class="separator:ae5ef9caa6cce3d62f088cd50f9b88b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e56bd76bb60ad0ba97bb171b4a9439"><td class="memItemLeft" align="right" valign="top"><a id="ae4e56bd76bb60ad0ba97bb171b4a9439"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae4e56bd76bb60ad0ba97bb171b4a9439">scarc_unpack_zone_types</a> (NM, NOM)</td></tr>
<tr class="memdesc:ae4e56bd76bb60ad0ba97bb171b4a9439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack zones information into send vector. <br /></td></tr>
<tr class="separator:ae4e56bd76bb60ad0ba97bb171b4a9439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709904eb11bef9974f04c6de01d88899"><td class="memItemLeft" align="right" valign="top"><a id="a709904eb11bef9974f04c6de01d88899"></a>
logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a709904eb11bef9974f04c6de01d88899">scarc_forbidden_zone</a> (SEND_BUFFER_INT, IZ, ICG1, ICG2)</td></tr>
<tr class="memdesc:a709904eb11bef9974f04c6de01d88899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if cell should be considered during packing of zone numbers. <br /></td></tr>
<tr class="separator:a709904eb11bef9974f04c6de01d88899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebcf049adddcdd5a5316d495581fdbc"><td class="memItemLeft" align="right" valign="top"><a id="a3ebcf049adddcdd5a5316d495581fdbc"></a>
logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a3ebcf049adddcdd5a5316d495581fdbc">match</a> (VAL1, VAL2)</td></tr>
<tr class="memdesc:a3ebcf049adddcdd5a5316d495581fdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if difference of two values is less than a given tolerance. <br /></td></tr>
<tr class="separator:a3ebcf049adddcdd5a5316d495581fdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cd478f862c783e66fc06cbe0792cec"><td class="memItemLeft" align="right" valign="top"><a id="ae2cd478f862c783e66fc06cbe0792cec"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae2cd478f862c783e66fc06cbe0792cec">scarc_filter_meanvalue</a> (NV, NL)</td></tr>
<tr class="memdesc:ae2cd478f862c783e66fc06cbe0792cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter out mean value. <br /></td></tr>
<tr class="separator:ae2cd478f862c783e66fc06cbe0792cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a500e2034392941522bbbd39617ba0"><td class="memItemLeft" align="right" valign="top"><a id="a04a500e2034392941522bbbd39617ba0"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a04a500e2034392941522bbbd39617ba0">scarc_restore_last_cell</a> (XX, NL)</td></tr>
<tr class="memdesc:a04a500e2034392941522bbbd39617ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore last cell of last mesh. <br /></td></tr>
<tr class="separator:a04a500e2034392941522bbbd39617ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f032499f0d33c4fe05fe8cfadd3d9c"><td class="memItemLeft" align="right" valign="top"><a id="af2f032499f0d33c4fe05fe8cfadd3d9c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#af2f032499f0d33c4fe05fe8cfadd3d9c">scarc_point_to_mesh</a> (NM)</td></tr>
<tr class="memdesc:af2f032499f0d33c4fe05fe8cfadd3d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified mesh. <br /></td></tr>
<tr class="separator:af2f032499f0d33c4fe05fe8cfadd3d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad289748d05ddb6d7ff08878b195ffd25"><td class="memItemLeft" align="right" valign="top"><a id="ad289748d05ddb6d7ff08878b195ffd25"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ad289748d05ddb6d7ff08878b195ffd25">scarc_point_to_level</a> (NM, NL)</td></tr>
<tr class="memdesc:ad289748d05ddb6d7ff08878b195ffd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified combination of mesh and grid level. <br /></td></tr>
<tr class="separator:ad289748d05ddb6d7ff08878b195ffd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce7af5db2f6dc96a87b3ee3977f27c0"><td class="memItemLeft" align="right" valign="top"><a id="a2ce7af5db2f6dc96a87b3ee3977f27c0"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a2ce7af5db2f6dc96a87b3ee3977f27c0">scarc_point_to_none</a></td></tr>
<tr class="memdesc:a2ce7af5db2f6dc96a87b3ee3977f27c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset ScaRC pointers <br  />
 <br /></td></tr>
<tr class="separator:a2ce7af5db2f6dc96a87b3ee3977f27c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3efd999d06703cb0d76a8ecb7d40c5"><td class="memItemLeft" align="right" valign="top"><a id="abb3efd999d06703cb0d76a8ecb7d40c5"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#abb3efd999d06703cb0d76a8ecb7d40c5">scarc_point_to_grid</a> (NM, NL)</td></tr>
<tr class="memdesc:abb3efd999d06703cb0d76a8ecb7d40c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified combination of a mesh level and discretization type. <br /></td></tr>
<tr class="separator:abb3efd999d06703cb0d76a8ecb7d40c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c92f38b46afb473c820b6d1046e4c7c"><td class="memItemLeft" align="right" valign="top"><a id="a4c92f38b46afb473c820b6d1046e4c7c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a4c92f38b46afb473c820b6d1046e4c7c">scarc_point_to_multigrid</a> (NM, NL1, NL2)</td></tr>
<tr class="memdesc:a4c92f38b46afb473c820b6d1046e4c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified pairing of mesh levels and discretization types. <br /></td></tr>
<tr class="separator:a4c92f38b46afb473c820b6d1046e4c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af184bf24e5e3171ed723f5542502997e"><td class="memItemLeft" align="right" valign="top"><a id="af184bf24e5e3171ed723f5542502997e"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#af184bf24e5e3171ed723f5542502997e">scarc_point_to_other_grid</a> (NM, NOM, NL)</td></tr>
<tr class="memdesc:af184bf24e5e3171ed723f5542502997e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified combination of a neighboring mesh level and discretization type. <br /></td></tr>
<tr class="separator:af184bf24e5e3171ed723f5542502997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbe9c8c170fcace7570314dbcd80ff8"><td class="memItemLeft" align="right" valign="top"><a id="a5bbe9c8c170fcace7570314dbcd80ff8"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a5bbe9c8c170fcace7570314dbcd80ff8">scarc_point_to_other_multigrid</a> (NM, NOM, NL1, NL2)</td></tr>
<tr class="memdesc:a5bbe9c8c170fcace7570314dbcd80ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified combination of a neighboring mesh level and a discretization type. <br /></td></tr>
<tr class="separator:a5bbe9c8c170fcace7570314dbcd80ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0744a85eaff5e87a4bd77d890158777"><td class="memItemLeft" align="right" valign="top"><a id="ab0744a85eaff5e87a4bd77d890158777"></a>
type(scarc_matrix_compact_type) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab0744a85eaff5e87a4bd77d890158777">scarc_point_to_cmatrix</a> (G, NTYPE)</td></tr>
<tr class="memdesc:ab0744a85eaff5e87a4bd77d890158777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified matrix in compact storage technique. <br /></td></tr>
<tr class="separator:ab0744a85eaff5e87a4bd77d890158777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752cbf4b14431984f5bfd98fbe1a2255"><td class="memItemLeft" align="right" valign="top"><a id="a752cbf4b14431984f5bfd98fbe1a2255"></a>
type(scarc_matrix_bandwise_type) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a752cbf4b14431984f5bfd98fbe1a2255">scarc_point_to_bmatrix</a> (G, NTYPE)</td></tr>
<tr class="memdesc:a752cbf4b14431984f5bfd98fbe1a2255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified matrix in bandwise storage technique. <br /></td></tr>
<tr class="separator:a752cbf4b14431984f5bfd98fbe1a2255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ad3b5f25841d4a79ad0d3f11484ef7"><td class="memItemLeft" align="right" valign="top"><a id="a16ad3b5f25841d4a79ad0d3f11484ef7"></a>
type(scarc_matrix_compact_type) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a16ad3b5f25841d4a79ad0d3f11484ef7">scarc_point_to_other_cmatrix</a> (OG, NTYPE)</td></tr>
<tr class="memdesc:a16ad3b5f25841d4a79ad0d3f11484ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified neighboring matrix in compact storage technique. <br /></td></tr>
<tr class="separator:a16ad3b5f25841d4a79ad0d3f11484ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466354430accb8d51a775e5750002af9"><td class="memItemLeft" align="right" valign="top"><a id="a466354430accb8d51a775e5750002af9"></a>
type(scarc_matrix_bandwise_type) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a466354430accb8d51a775e5750002af9">scarc_point_to_other_bmatrix</a> (OG, NTYPE)</td></tr>
<tr class="memdesc:a466354430accb8d51a775e5750002af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified neighboring matrix in bandwise storage technique. <br /></td></tr>
<tr class="separator:a466354430accb8d51a775e5750002af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae067ddfd27723f9aea38e7ab45e6336b"><td class="memItemLeft" align="right" valign="top"><a id="ae067ddfd27723f9aea38e7ab45e6336b"></a>
integer function, dimension(:), pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae067ddfd27723f9aea38e7ab45e6336b">scarc_point_to_buffer_int</a> (NM, NOM, NTYPE)</td></tr>
<tr class="memdesc:ae067ddfd27723f9aea38e7ab45e6336b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified integer receive buffer for data exchanges. <br /></td></tr>
<tr class="separator:ae067ddfd27723f9aea38e7ab45e6336b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e67309d2a827395a9c7c53704e1c27"><td class="memItemLeft" align="right" valign="top"><a id="a83e67309d2a827395a9c7c53704e1c27"></a>
real(eb) function, dimension(:), pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a83e67309d2a827395a9c7c53704e1c27">scarc_point_to_buffer_real</a> (NM, NOM, NTYPE)</td></tr>
<tr class="memdesc:a83e67309d2a827395a9c7c53704e1c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified integer receive buffer for data exchanges. <br /></td></tr>
<tr class="separator:a83e67309d2a827395a9c7c53704e1c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942f1359918daa404c92beb6e7f6684d"><td class="memItemLeft" align="right" valign="top"><a id="a942f1359918daa404c92beb6e7f6684d"></a>
logical function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a942f1359918daa404c92beb6e7f6684d">are_neighbors</a> (NM, NOM)</td></tr>
<tr class="memdesc:a942f1359918daa404c92beb6e7f6684d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two meshes are neighbors. <br /></td></tr>
<tr class="separator:a942f1359918daa404c92beb6e7f6684d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc380711ccad0b54f44cc03e4e26bfd"><td class="memItemLeft" align="right" valign="top"><a id="afbc380711ccad0b54f44cc03e4e26bfd"></a>
real(eb) function, dimension(:), pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#afbc380711ccad0b54f44cc03e4e26bfd">scarc_point_to_vector</a> (NM, NL, NV)</td></tr>
<tr class="memdesc:afbc380711ccad0b54f44cc03e4e26bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified vector on a given grid level. <br /></td></tr>
<tr class="separator:afbc380711ccad0b54f44cc03e4e26bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf96189a8b8f36b049db0ff41965c537"><td class="memItemLeft" align="right" valign="top"><a id="aaf96189a8b8f36b049db0ff41965c537"></a>
real(fb) function, dimension(:), pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aaf96189a8b8f36b049db0ff41965c537">scarc_point_to_vector_fb</a> (NM, NL, NV)</td></tr>
<tr class="memdesc:aaf96189a8b8f36b049db0ff41965c537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to specified vector on a given grid level (single precision version) <br /></td></tr>
<tr class="separator:aaf96189a8b8f36b049db0ff41965c537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728848a709bb7689d6cdf5a39ff8b77f"><td class="memItemLeft" align="right" valign="top"><a id="a728848a709bb7689d6cdf5a39ff8b77f"></a>
real(eb) function, dimension(:,:,:), pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a728848a709bb7689d6cdf5a39ff8b77f">point_to_hvector</a> (NM, NV)</td></tr>
<tr class="memdesc:a728848a709bb7689d6cdf5a39ff8b77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point to pressure vector in predictor or corrector. <br /></td></tr>
<tr class="separator:a728848a709bb7689d6cdf5a39ff8b77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca98154b949f84ed3a9d18d26204fce"><td class="memItemLeft" align="right" valign="top"><a id="adca98154b949f84ed3a9d18d26204fce"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#adca98154b949f84ed3a9d18d26204fce">scarc_daxpy_constant</a> (N, DA, DX, DY)</td></tr>
<tr class="memdesc:adca98154b949f84ed3a9d18d26204fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiplied with a constant scalar is added to another vector. <br /></td></tr>
<tr class="separator:adca98154b949f84ed3a9d18d26204fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e7a45694f0d794c01f33947583ac0a"><td class="memItemLeft" align="right" valign="top"><a id="a80e7a45694f0d794c01f33947583ac0a"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a80e7a45694f0d794c01f33947583ac0a">scarc_daxpy_constant_double</a> (N, DA1, DX, DA2, DY)</td></tr>
<tr class="memdesc:a80e7a45694f0d794c01f33947583ac0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiplied with a constant scalar is added to vector multiplied with another scalar. <br /></td></tr>
<tr class="separator:a80e7a45694f0d794c01f33947583ac0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d4cf66d829ea95e3c8fbeeeaa1ad82"><td class="memItemLeft" align="right" valign="top"><a id="a47d4cf66d829ea95e3c8fbeeeaa1ad82"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a47d4cf66d829ea95e3c8fbeeeaa1ad82">scarc_daxpy_variable</a> (N, DA, DX, DY)</td></tr>
<tr class="memdesc:a47d4cf66d829ea95e3c8fbeeeaa1ad82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector multiplied with variable scalars (componentwise) is added to another vector. <br /></td></tr>
<tr class="separator:a47d4cf66d829ea95e3c8fbeeeaa1ad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab135b8963f1df96a99d9941255b18d7c"><td class="memItemLeft" align="right" valign="top"><a id="ab135b8963f1df96a99d9941255b18d7c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab135b8963f1df96a99d9941255b18d7c">scarc_scaling_constant</a> (N, SCAL, DX, DY)</td></tr>
<tr class="memdesc:ab135b8963f1df96a99d9941255b18d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector is multiplied with a constant scalar. <br /></td></tr>
<tr class="separator:ab135b8963f1df96a99d9941255b18d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e77913a6263102013843209cfd9c40"><td class="memItemLeft" align="right" valign="top"><a id="a53e77913a6263102013843209cfd9c40"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a53e77913a6263102013843209cfd9c40">scarc_scaling_variable</a> (N, DA, DX, DY)</td></tr>
<tr class="memdesc:a53e77913a6263102013843209cfd9c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector is multiplied with variable scalars (componentwise) <br /></td></tr>
<tr class="separator:a53e77913a6263102013843209cfd9c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86ad2f72b1250040b214018e1de4422"><td class="memItemLeft" align="right" valign="top"><a id="ac86ad2f72b1250040b214018e1de4422"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac86ad2f72b1250040b214018e1de4422">scarc_setup_algebraic_multigrid</a></td></tr>
<tr class="memdesc:ac86ad2f72b1250040b214018e1de4422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup algebraic multigrid structures. <br /></td></tr>
<tr class="separator:ac86ad2f72b1250040b214018e1de4422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237a353cbe79126ef3a278781eaca079"><td class="memItemLeft" align="right" valign="top"><a id="a237a353cbe79126ef3a278781eaca079"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a237a353cbe79126ef3a278781eaca079">scarc_setup_aggregation_order</a></td></tr>
<tr class="memdesc:a237a353cbe79126ef3a278781eaca079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup order in which aggregation is performed over mesh decomposition. <br /></td></tr>
<tr class="separator:a237a353cbe79126ef3a278781eaca079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eca568af7e97c9ed88d192d6856ca39"><td class="memItemLeft" align="right" valign="top"><a id="a8eca568af7e97c9ed88d192d6856ca39"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a8eca568af7e97c9ed88d192d6856ca39">scarc_invert_matrix_diagonal</a> (NL)</td></tr>
<tr class="memdesc:a8eca568af7e97c9ed88d192d6856ca39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert matrix diagonal which is already stored in DIAG-vector (reuse workspace) <br /></td></tr>
<tr class="separator:a8eca568af7e97c9ed88d192d6856ca39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177ade5012c44b7f936a004fce3726e9"><td class="memItemLeft" align="right" valign="top"><a id="a177ade5012c44b7f936a004fce3726e9"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a177ade5012c44b7f936a004fce3726e9">scarc_setup_strength_of_connection</a> (NL)</td></tr>
<tr class="memdesc:a177ade5012c44b7f936a004fce3726e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a strength of connection matrix based on symmetric smoothed aggregation heuristic. <br /></td></tr>
<tr class="separator:a177ade5012c44b7f936a004fce3726e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab700004745ef4a15f8c6aa6da13875db"><td class="memItemLeft" align="right" valign="top"><a id="ab700004745ef4a15f8c6aa6da13875db"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab700004745ef4a15f8c6aa6da13875db">scarc_setup_aggregation_zones</a> (NL)</td></tr>
<tr class="memdesc:ab700004745ef4a15f8c6aa6da13875db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup aggregation zones for Smoothed Aggregation Algebraic Multigrid Method. <br /></td></tr>
<tr class="separator:ab700004745ef4a15f8c6aa6da13875db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a34ec6914cb8d90b33822794fd4a69f"><td class="memItemLeft" align="right" valign="top"><a id="a9a34ec6914cb8d90b33822794fd4a69f"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a9a34ec6914cb8d90b33822794fd4a69f">scarc_setup_aggregated_zones</a> (NM, G, C)</td></tr>
<tr class="memdesc:a9a34ec6914cb8d90b33822794fd4a69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard aggregation prodecure based on strength of connection matrix. <br /></td></tr>
<tr class="separator:a9a34ec6914cb8d90b33822794fd4a69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b571c34337d7e86d2ecd1c54fa81a46"><td class="memItemLeft" align="right" valign="top"><a id="a3b571c34337d7e86d2ecd1c54fa81a46"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a3b571c34337d7e86d2ecd1c54fa81a46">scarc_setup_cubic_zones</a> (L, G)</td></tr>
<tr class="memdesc:a3b571c34337d7e86d2ecd1c54fa81a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selfdefined geometric motivated aggregation procedure using cubic zones. <br /></td></tr>
<tr class="separator:a3b571c34337d7e86d2ecd1c54fa81a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671a523798823a0fcc66cd12a975b901"><td class="memItemLeft" align="right" valign="top"><a id="a671a523798823a0fcc66cd12a975b901"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a671a523798823a0fcc66cd12a975b901">scarc_clean_workspace_system</a> (NL)</td></tr>
<tr class="memdesc:a671a523798823a0fcc66cd12a975b901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove workspace on specified grid level which will no longer be needed after matrix setup. <br /></td></tr>
<tr class="separator:a671a523798823a0fcc66cd12a975b901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3743741d9c04b991dc47507801bb81"><td class="memItemLeft" align="right" valign="top"><a id="abb3743741d9c04b991dc47507801bb81"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#abb3743741d9c04b991dc47507801bb81">scarc_clean_workspace_amg</a> (NL)</td></tr>
<tr class="memdesc:abb3743741d9c04b991dc47507801bb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove workspace on specified grid level which will no longer be needed in SAMG method. <br /></td></tr>
<tr class="separator:abb3743741d9c04b991dc47507801bb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b8586639e5a92c163847e753f07027"><td class="memItemLeft" align="right" valign="top"><a id="a67b8586639e5a92c163847e753f07027"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a67b8586639e5a92c163847e753f07027">scarc_relax_nullspace</a> (NL)</td></tr>
<tr class="memdesc:a67b8586639e5a92c163847e753f07027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform relaxation of nullspac. <br /></td></tr>
<tr class="separator:a67b8586639e5a92c163847e753f07027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa005c07a402b454d68b6b298a5093cdd"><td class="memItemLeft" align="right" valign="top"><a id="aa005c07a402b454d68b6b298a5093cdd"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aa005c07a402b454d68b6b298a5093cdd">scarc_setup_zone_operator</a> (NL)</td></tr>
<tr class="memdesc:aa005c07a402b454d68b6b298a5093cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup basic structure of prolongation matrix. <br /></td></tr>
<tr class="separator:aa005c07a402b454d68b6b298a5093cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab121963cf86a14181ac1d4039e33cd5e"><td class="memItemLeft" align="right" valign="top"><a id="ab121963cf86a14181ac1d4039e33cd5e"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab121963cf86a14181ac1d4039e33cd5e">scarc_setup_prolongation</a> (NL)</td></tr>
<tr class="memdesc:ab121963cf86a14181ac1d4039e33cd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine tentative prolongator for current level by computing QR-decomposition of smoothed. <br /></td></tr>
<tr class="separator:ab121963cf86a14181ac1d4039e33cd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab683054800a7b43b7b4274c33ac9154f"><td class="memItemLeft" align="right" valign="top"><a id="ab683054800a7b43b7b4274c33ac9154f"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab683054800a7b43b7b4274c33ac9154f">scarc_setup_nullspace_coarse</a> (NL)</td></tr>
<tr class="memdesc:ab683054800a7b43b7b4274c33ac9154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define nullspace for next coarser level, if coarsest level isn't reached yet. <br /></td></tr>
<tr class="separator:ab683054800a7b43b7b4274c33ac9154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbe7cc878a94c74c8bc183675e6fc4a"><td class="memItemLeft" align="right" valign="top"><a id="a6fbe7cc878a94c74c8bc183675e6fc4a"></a>
integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a6fbe7cc878a94c74c8bc183675e6fc4a">scarc_match_matrix_column</a> (A, IC, JC)</td></tr>
<tr class="memdesc:a6fbe7cc878a94c74c8bc183675e6fc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which columns of system matrix are involved in multiplication with tentative prolongator. <br /></td></tr>
<tr class="separator:a6fbe7cc878a94c74c8bc183675e6fc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3ad2b4066b31ed619563314c125103"><td class="memItemLeft" align="right" valign="top"><a id="a2e3ad2b4066b31ed619563314c125103"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a2e3ad2b4066b31ed619563314c125103">scarc_setup_restriction</a> (NL)</td></tr>
<tr class="memdesc:a2e3ad2b4066b31ed619563314c125103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup restriction matrix: Build transpose of prolongation matrix. <br /></td></tr>
<tr class="separator:a2e3ad2b4066b31ed619563314c125103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f082c3ec75a6b17adc300c04a16757"><td class="memItemLeft" align="right" valign="top"><a id="a04f082c3ec75a6b17adc300c04a16757"></a>
integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a04f082c3ec75a6b17adc300c04a16757">scarc_find_matching_column</a> (A, JC, ICCG)</td></tr>
<tr class="memdesc:a04f082c3ec75a6b17adc300c04a16757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find matching column index during matrix-matrix multiplication of compact matrices. <br /></td></tr>
<tr class="separator:a04f082c3ec75a6b17adc300c04a16757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6763b5f9046a7985685acfcbc21264"><td class="memItemLeft" align="right" valign="top"><a id="adb6763b5f9046a7985685acfcbc21264"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#adb6763b5f9046a7985685acfcbc21264">scarc_setup_poisson_times_prol</a> (NL)</td></tr>
<tr class="memdesc:adb6763b5f9046a7985685acfcbc21264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform matrix multiplication between fine Poisson matrix and prolongation matrix. <br /></td></tr>
<tr class="separator:adb6763b5f9046a7985685acfcbc21264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03acb90019f3107fd7ca61c23bb57b1b"><td class="memItemLeft" align="right" valign="top"><a id="a03acb90019f3107fd7ca61c23bb57b1b"></a>
integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a03acb90019f3107fd7ca61c23bb57b1b">scarc_map_global_to_local</a> (G, ICG, NM, NL)</td></tr>
<tr class="memdesc:a03acb90019f3107fd7ca61c23bb57b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map global to local cell number. <br /></td></tr>
<tr class="separator:a03acb90019f3107fd7ca61c23bb57b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac099a7ed22a82f0e1b9a7b8b70c6463e"><td class="memItemLeft" align="right" valign="top"><a id="ac099a7ed22a82f0e1b9a7b8b70c6463e"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac099a7ed22a82f0e1b9a7b8b70c6463e">scarc_setup_galerkin</a> (NL)</td></tr>
<tr class="memdesc:ac099a7ed22a82f0e1b9a7b8b70c6463e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup Galerkin matrix on coarser grid level (AMG only) <br /></td></tr>
<tr class="separator:ac099a7ed22a82f0e1b9a7b8b70c6463e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492988d5c1f4e3639ba46c9029b9ab39"><td class="memItemLeft" align="right" valign="top"><a id="a492988d5c1f4e3639ba46c9029b9ab39"></a>
double precision function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a492988d5c1f4e3639ba46c9029b9ab39">scarc_value_rap</a> (IC, ICC)</td></tr>
<tr class="memdesc:a492988d5c1f4e3639ba46c9029b9ab39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute entry of Poisson times Prolongation matrix at specified position. <br /></td></tr>
<tr class="separator:a492988d5c1f4e3639ba46c9029b9ab39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985fc72f55b09a4d96a51f9a1682b023"><td class="memItemLeft" align="right" valign="top"><a id="a985fc72f55b09a4d96a51f9a1682b023"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a985fc72f55b09a4d96a51f9a1682b023">scarc_resort_matrix_rows</a> (NL)</td></tr>
<tr class="memdesc:a985fc72f55b09a4d96a51f9a1682b023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resort matrix entries such that diagonal entry comes first (compact storage technique only) <br /></td></tr>
<tr class="separator:a985fc72f55b09a4d96a51f9a1682b023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e934f0f13ed9fdeaf647eec22ec426"><td class="memItemLeft" align="right" valign="top"><a id="af7e934f0f13ed9fdeaf647eec22ec426"></a>
double precision function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#af7e934f0f13ed9fdeaf647eec22ec426">exact</a> (X, Z)</td></tr>
<tr class="memdesc:af7e934f0f13ed9fdeaf647eec22ec426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set exact solution according to specified function. <br /></td></tr>
<tr class="separator:af7e934f0f13ed9fdeaf647eec22ec426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd4dbd700a8b17a34407fde79bb0461"><td class="memItemLeft" align="right" valign="top"><a id="adbd4dbd700a8b17a34407fde79bb0461"></a>
double precision function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#adbd4dbd700a8b17a34407fde79bb0461">rhs</a> (X, Z)</td></tr>
<tr class="memdesc:adbd4dbd700a8b17a34407fde79bb0461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set right hand side according to specified function. <br /></td></tr>
<tr class="separator:adbd4dbd700a8b17a34407fde79bb0461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dec783e22e1fa159699d96b98af1d91"><td class="memItemLeft" align="right" valign="top"><a id="a3dec783e22e1fa159699d96b98af1d91"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a3dec783e22e1fa159699d96b98af1d91">scarc_preset_exact</a> (NE, NL)</td></tr>
<tr class="memdesc:a3dec783e22e1fa159699d96b98af1d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preset right hand side in such a way that exact solution is known. <br /></td></tr>
<tr class="separator:a3dec783e22e1fa159699d96b98af1d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509034cce4d97501c3502aaa0e793c8f"><td class="memItemLeft" align="right" valign="top"><a id="a509034cce4d97501c3502aaa0e793c8f"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a509034cce4d97501c3502aaa0e793c8f">scarc_preset_vector</a> (NV, NL)</td></tr>
<tr class="memdesc:a509034cce4d97501c3502aaa0e793c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preset vector with specific values. <br /></td></tr>
<tr class="separator:a509034cce4d97501c3502aaa0e793c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820701910407eff05a660aafdf1cd499"><td class="memItemLeft" align="right" valign="top"><a id="a820701910407eff05a660aafdf1cd499"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a820701910407eff05a660aafdf1cd499">scarc_preset_rhs</a> (NV, NL)</td></tr>
<tr class="memdesc:a820701910407eff05a660aafdf1cd499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preset right hand side in such a way that exact solution is known. <br /></td></tr>
<tr class="separator:a820701910407eff05a660aafdf1cd499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffc82b7a43c0dd7735d99926a90fb72"><td class="memItemLeft" align="right" valign="top"><a id="aaffc82b7a43c0dd7735d99926a90fb72"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aaffc82b7a43c0dd7735d99926a90fb72">scarc_update_memory</a> (NDATA, NSTATE, NDIM, NINIT, NL1, NR1, NL2, NR2, NL3, NR3, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:aaffc82b7a43c0dd7735d99926a90fb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update list of arrays within ScaRC memory management. <br /></td></tr>
<tr class="separator:aaffc82b7a43c0dd7735d99926a90fb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b5efcf97add55ba20a8b32c29525f9"><td class="memItemLeft" align="right" valign="top"><a id="a54b5efcf97add55ba20a8b32c29525f9"></a>
integer function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a54b5efcf97add55ba20a8b32c29525f9">scarc_update_memory_counters</a> (NDATA, NP, NSCAL)</td></tr>
<tr class="memdesc:a54b5efcf97add55ba20a8b32c29525f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update memory statistics w.r.t to occupied workspace and number of allocated arrays. <br /></td></tr>
<tr class="separator:a54b5efcf97add55ba20a8b32c29525f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2630884663e225b5a620963f664c06a3"><td class="memItemLeft" align="right" valign="top"><a id="a2630884663e225b5a620963f664c06a3"></a>
character(10) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a2630884663e225b5a620963f664c06a3">scarc_get_memory_state</a> (NSTATE, NDATA, NWORK, NSUM)</td></tr>
<tr class="memdesc:a2630884663e225b5a620963f664c06a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get full text information about the allocation state of the currently processed array. <br /></td></tr>
<tr class="separator:a2630884663e225b5a620963f664c06a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cd3273edaa6f4b4c10b70aa7db1177"><td class="memItemLeft" align="right" valign="top"><a id="a89cd3273edaa6f4b4c10b70aa7db1177"></a>
character(10) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a89cd3273edaa6f4b4c10b70aa7db1177">scarc_get_data_type</a> (NDATA)</td></tr>
<tr class="memdesc:a89cd3273edaa6f4b4c10b70aa7db1177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get full text information about the data type of the currently processed array. <br /></td></tr>
<tr class="separator:a89cd3273edaa6f4b4c10b70aa7db1177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148308edac1ebf7d33d7afcc1588286b"><td class="memItemLeft" align="right" valign="top"><a id="a148308edac1ebf7d33d7afcc1588286b"></a>
character(10) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a148308edac1ebf7d33d7afcc1588286b">scarc_get_dimension</a> (NDIM)</td></tr>
<tr class="memdesc:a148308edac1ebf7d33d7afcc1588286b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get full text information about the dimension of the currently processed array. <br /></td></tr>
<tr class="separator:a148308edac1ebf7d33d7afcc1588286b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8d35120dcb659bc9ace6fc3ad6266a"><td class="memItemLeft" align="right" valign="top"><a id="aed8d35120dcb659bc9ace6fc3ad6266a"></a>
character(10) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aed8d35120dcb659bc9ace6fc3ad6266a">scarc_get_init_type</a> (NINIT)</td></tr>
<tr class="memdesc:aed8d35120dcb659bc9ace6fc3ad6266a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get full text information about the initialization type of the currently processed array. <br /></td></tr>
<tr class="separator:aed8d35120dcb659bc9ace6fc3ad6266a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d182af69aeeb13f327a6006e2f1a2dd"><td class="memItemLeft" align="right" valign="top"><a id="a9d182af69aeeb13f327a6006e2f1a2dd"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a9d182af69aeeb13f327a6006e2f1a2dd">scarc_allocate_int1</a> (WORKSPACE, NL1, NR1, NINIT, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a9d182af69aeeb13f327a6006e2f1a2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize integer array of dimension 1. <br /></td></tr>
<tr class="separator:a9d182af69aeeb13f327a6006e2f1a2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec49704e3423a7892e2ea407c79b432"><td class="memItemLeft" align="right" valign="top"><a id="a5ec49704e3423a7892e2ea407c79b432"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a5ec49704e3423a7892e2ea407c79b432">scarc_allocate_int2</a> (WORKSPACE, NL1, NR1, NL2, NR2, NINIT, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a5ec49704e3423a7892e2ea407c79b432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize integer array of dimension 2. <br /></td></tr>
<tr class="separator:a5ec49704e3423a7892e2ea407c79b432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a85c2a09b81325d50a31a24313650c"><td class="memItemLeft" align="right" valign="top"><a id="ac4a85c2a09b81325d50a31a24313650c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac4a85c2a09b81325d50a31a24313650c">scarc_allocate_int3</a> (WORKSPACE, NL1, NR1, NL2, NR2, NL3, NR3, NINIT, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:ac4a85c2a09b81325d50a31a24313650c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize integer array of dimension 3. <br /></td></tr>
<tr class="separator:ac4a85c2a09b81325d50a31a24313650c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6e1c1740f885464c025cbed6c65b3d"><td class="memItemLeft" align="right" valign="top"><a id="afc6e1c1740f885464c025cbed6c65b3d"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#afc6e1c1740f885464c025cbed6c65b3d">scarc_allocate_log1</a> (WORKSPACE, NL1, NR1, NINIT, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:afc6e1c1740f885464c025cbed6c65b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize Logical array of dimension 1. <br /></td></tr>
<tr class="separator:afc6e1c1740f885464c025cbed6c65b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442159c9c41c6bc0a9d8a8354d92149b"><td class="memItemLeft" align="right" valign="top"><a id="a442159c9c41c6bc0a9d8a8354d92149b"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a442159c9c41c6bc0a9d8a8354d92149b">scarc_allocate_log2</a> (WORKSPACE, NL1, NR1, NL2, NR2, NINIT, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a442159c9c41c6bc0a9d8a8354d92149b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize Logical array of dimension 2. <br /></td></tr>
<tr class="separator:a442159c9c41c6bc0a9d8a8354d92149b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d67550251fbeb080d440aea70acccbf"><td class="memItemLeft" align="right" valign="top"><a id="a5d67550251fbeb080d440aea70acccbf"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a5d67550251fbeb080d440aea70acccbf">scarc_allocate_log3</a> (WORKSPACE, NL1, NR1, NL2, NR2, NL3, NR3, NINIT, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a5d67550251fbeb080d440aea70acccbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize Logical array of dimension 3. <br /></td></tr>
<tr class="separator:a5d67550251fbeb080d440aea70acccbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f735ac8f173c76c36f64276a82ebb06"><td class="memItemLeft" align="right" valign="top"><a id="a9f735ac8f173c76c36f64276a82ebb06"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a9f735ac8f173c76c36f64276a82ebb06">scarc_allocate_real1</a> (WORKSPACE, NL1, NR1, NINIT, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a9f735ac8f173c76c36f64276a82ebb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize real array of dimension 1. <br /></td></tr>
<tr class="separator:a9f735ac8f173c76c36f64276a82ebb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56145f115a7e676c3ad096aeb6a50d64"><td class="memItemLeft" align="right" valign="top"><a id="a56145f115a7e676c3ad096aeb6a50d64"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a56145f115a7e676c3ad096aeb6a50d64">scarc_allocate_real1_fb</a> (WORKSPACE, NL1, NR1, NINIT, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a56145f115a7e676c3ad096aeb6a50d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize real array of dimension 1. <br /></td></tr>
<tr class="separator:a56145f115a7e676c3ad096aeb6a50d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f893823eb05a975801214bdcade2b76"><td class="memItemLeft" align="right" valign="top"><a id="a4f893823eb05a975801214bdcade2b76"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a4f893823eb05a975801214bdcade2b76">scarc_allocate_real2</a> (WORKSPACE, NL1, NR1, NL2, NR2, NINIT, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a4f893823eb05a975801214bdcade2b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize real array of dimension 2. <br /></td></tr>
<tr class="separator:a4f893823eb05a975801214bdcade2b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e341929cf761499c0b4925aeb8d3532"><td class="memItemLeft" align="right" valign="top"><a id="a4e341929cf761499c0b4925aeb8d3532"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a4e341929cf761499c0b4925aeb8d3532">scarc_allocate_real3</a> (WORKSPACE, NL1, NR1, NL2, NR2, NL3, NR3, NINIT, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a4e341929cf761499c0b4925aeb8d3532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize real array of dimension 3. <br /></td></tr>
<tr class="separator:a4e341929cf761499c0b4925aeb8d3532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9cfa1f30730263d4c9d90b2ba67e71"><td class="memItemLeft" align="right" valign="top"><a id="a5d9cfa1f30730263d4c9d90b2ba67e71"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a5d9cfa1f30730263d4c9d90b2ba67e71">scarc_deallocate_int1</a> (WORKSPACE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a5d9cfa1f30730263d4c9d90b2ba67e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate one-dimensional integer vector. <br /></td></tr>
<tr class="separator:a5d9cfa1f30730263d4c9d90b2ba67e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bffe8ac5dbca90100b734697360a59c"><td class="memItemLeft" align="right" valign="top"><a id="a7bffe8ac5dbca90100b734697360a59c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a7bffe8ac5dbca90100b734697360a59c">scarc_deallocate_int2</a> (WORKSPACE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a7bffe8ac5dbca90100b734697360a59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate two-dimensional integer vector. <br /></td></tr>
<tr class="separator:a7bffe8ac5dbca90100b734697360a59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46f99fb777feb500c6404fa8219bd55"><td class="memItemLeft" align="right" valign="top"><a id="ac46f99fb777feb500c6404fa8219bd55"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac46f99fb777feb500c6404fa8219bd55">scarc_deallocate_int3</a> (WORKSPACE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:ac46f99fb777feb500c6404fa8219bd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate three-dimensional integer vector. <br /></td></tr>
<tr class="separator:ac46f99fb777feb500c6404fa8219bd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701adc05ffec4243a4e536f573c6f7c1"><td class="memItemLeft" align="right" valign="top"><a id="a701adc05ffec4243a4e536f573c6f7c1"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a701adc05ffec4243a4e536f573c6f7c1">scarc_deallocate_log1</a> (WORKSPACE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a701adc05ffec4243a4e536f573c6f7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate one-dimensional logical vector. <br /></td></tr>
<tr class="separator:a701adc05ffec4243a4e536f573c6f7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d7a7c0430c9a11ea684cbd9ad24016"><td class="memItemLeft" align="right" valign="top"><a id="af3d7a7c0430c9a11ea684cbd9ad24016"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#af3d7a7c0430c9a11ea684cbd9ad24016">scarc_deallocate_log2</a> (WORKSPACE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:af3d7a7c0430c9a11ea684cbd9ad24016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate two-dimensional logical vector. <br /></td></tr>
<tr class="separator:af3d7a7c0430c9a11ea684cbd9ad24016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e2cb36456d10a2114d09e25693266d"><td class="memItemLeft" align="right" valign="top"><a id="ae5e2cb36456d10a2114d09e25693266d"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae5e2cb36456d10a2114d09e25693266d">scarc_deallocate_log3</a> (WORKSPACE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:ae5e2cb36456d10a2114d09e25693266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate three-dimensional logical vector. <br /></td></tr>
<tr class="separator:ae5e2cb36456d10a2114d09e25693266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74543e3ad9ef34f7c0a9f8666999b6d8"><td class="memItemLeft" align="right" valign="top"><a id="a74543e3ad9ef34f7c0a9f8666999b6d8"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a74543e3ad9ef34f7c0a9f8666999b6d8">scarc_deallocate_real1</a> (WORKSPACE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a74543e3ad9ef34f7c0a9f8666999b6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate one-dimensional double precision vector. <br /></td></tr>
<tr class="separator:a74543e3ad9ef34f7c0a9f8666999b6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367546cdb84b0d9da05f182974d20d7b"><td class="memItemLeft" align="right" valign="top"><a id="a367546cdb84b0d9da05f182974d20d7b"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a367546cdb84b0d9da05f182974d20d7b">scarc_deallocate_real2</a> (WORKSPACE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a367546cdb84b0d9da05f182974d20d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate two-dimensional double precision vector. <br /></td></tr>
<tr class="separator:a367546cdb84b0d9da05f182974d20d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3c95dec78ab7e253f80f6560e6b95f"><td class="memItemLeft" align="right" valign="top"><a id="acd3c95dec78ab7e253f80f6560e6b95f"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#acd3c95dec78ab7e253f80f6560e6b95f">scarc_deallocate_real3</a> (WORKSPACE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:acd3c95dec78ab7e253f80f6560e6b95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate three-dimensional double precision vector. <br /></td></tr>
<tr class="separator:acd3c95dec78ab7e253f80f6560e6b95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2350d607a8670832124579256e0704"><td class="memItemLeft" align="right" valign="top"><a id="abf2350d607a8670832124579256e0704"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#abf2350d607a8670832124579256e0704">scarc_deallocate_real1_fb</a> (WORKSPACE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:abf2350d607a8670832124579256e0704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate one-dimensional single precision vector. <br /></td></tr>
<tr class="separator:abf2350d607a8670832124579256e0704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2381f4db1fb6fa20b429239d9b14b62"><td class="memItemLeft" align="right" valign="top"><a id="ac2381f4db1fb6fa20b429239d9b14b62"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac2381f4db1fb6fa20b429239d9b14b62">scarc_deallocate_real2_fb</a> (WORKSPACE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:ac2381f4db1fb6fa20b429239d9b14b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate one-dimensional single precision vector. <br /></td></tr>
<tr class="separator:ac2381f4db1fb6fa20b429239d9b14b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911ec02dadc8b75b89db14ff3a7f7035"><td class="memItemLeft" align="right" valign="top"><a id="a911ec02dadc8b75b89db14ff3a7f7035"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a911ec02dadc8b75b89db14ff3a7f7035">scarc_deallocate_real3_fb</a> (WORKSPACE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a911ec02dadc8b75b89db14ff3a7f7035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate one-dimensional single precision vector. <br /></td></tr>
<tr class="separator:a911ec02dadc8b75b89db14ff3a7f7035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b66d3ab71c0c43417cdeb5251f6cb79"><td class="memItemLeft" align="right" valign="top"><a id="a6b66d3ab71c0c43417cdeb5251f6cb79"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a6b66d3ab71c0c43417cdeb5251f6cb79">scarc_resize_int1</a> (WORKSPACE, NL1, NR1, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a6b66d3ab71c0c43417cdeb5251f6cb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize one-dimensional integer vector to requested bounds. <br /></td></tr>
<tr class="separator:a6b66d3ab71c0c43417cdeb5251f6cb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3c8dd890d38ba0b660813619fe7272"><td class="memItemLeft" align="right" valign="top"><a id="a1d3c8dd890d38ba0b660813619fe7272"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a1d3c8dd890d38ba0b660813619fe7272">scarc_resize_int2</a> (WORKSPACE, NL1, NR1, NL2, NR2, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a1d3c8dd890d38ba0b660813619fe7272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize two-dimensional integer vector to requested bounds. <br /></td></tr>
<tr class="separator:a1d3c8dd890d38ba0b660813619fe7272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddbfb38d08978a4a37d2e270690c2d4"><td class="memItemLeft" align="right" valign="top"><a id="a6ddbfb38d08978a4a37d2e270690c2d4"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a6ddbfb38d08978a4a37d2e270690c2d4">scarc_reduce_int1</a> (WORKSPACE, NSIZE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a6ddbfb38d08978a4a37d2e270690c2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce size of integer vector. <br /></td></tr>
<tr class="separator:a6ddbfb38d08978a4a37d2e270690c2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a68343165d767f256b53b4823595fb"><td class="memItemLeft" align="right" valign="top"><a id="a24a68343165d767f256b53b4823595fb"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a24a68343165d767f256b53b4823595fb">scarc_reduce_int2</a> (WORKSPACE, NSIZE1, NSIZE2, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a24a68343165d767f256b53b4823595fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce size of integer array with dimension 2. <br /></td></tr>
<tr class="separator:a24a68343165d767f256b53b4823595fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1a3dbae047a087652ea9e5bebb523a"><td class="memItemLeft" align="right" valign="top"><a id="abd1a3dbae047a087652ea9e5bebb523a"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#abd1a3dbae047a087652ea9e5bebb523a">scarc_expand_int1</a> (WORKSPACE, WORKSPACE_ADD, NSIZE, NSIZE_ADD, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:abd1a3dbae047a087652ea9e5bebb523a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand size of integer vector. <br /></td></tr>
<tr class="separator:abd1a3dbae047a087652ea9e5bebb523a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455c11d4ff2541fd7cac60790921201c"><td class="memItemLeft" align="right" valign="top"><a id="a455c11d4ff2541fd7cac60790921201c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a455c11d4ff2541fd7cac60790921201c">scarc_reduce_real1</a> (WORKSPACE, NSIZE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a455c11d4ff2541fd7cac60790921201c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce size of integer vector. <br /></td></tr>
<tr class="separator:a455c11d4ff2541fd7cac60790921201c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27436ca011fc0362c66c37689bcb1819"><td class="memItemLeft" align="right" valign="top"><a id="a27436ca011fc0362c66c37689bcb1819"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a27436ca011fc0362c66c37689bcb1819">scarc_allocate_cmatrix</a> (A, NL, NPREC, NTYPE, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a27436ca011fc0362c66c37689bcb1819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate matrix in compact storage format. <br /></td></tr>
<tr class="separator:a27436ca011fc0362c66c37689bcb1819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4f85d91bdf77d24165f7a5aeb97c8d"><td class="memItemLeft" align="right" valign="top"><a id="a0f4f85d91bdf77d24165f7a5aeb97c8d"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a0f4f85d91bdf77d24165f7a5aeb97c8d">scarc_deallocate_cmatrix</a> (A, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a0f4f85d91bdf77d24165f7a5aeb97c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dellocate matrix in compact storage format. <br /></td></tr>
<tr class="separator:a0f4f85d91bdf77d24165f7a5aeb97c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf723643fc2adbb6bd6cdd4ec993991"><td class="memItemLeft" align="right" valign="top"><a id="aecf723643fc2adbb6bd6cdd4ec993991"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aecf723643fc2adbb6bd6cdd4ec993991">scarc_reduce_cmatrix</a> (A, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:aecf723643fc2adbb6bd6cdd4ec993991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce size of matrix in compact storage format. <br /></td></tr>
<tr class="separator:aecf723643fc2adbb6bd6cdd4ec993991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571ffa12b5390630c2f89f0e19bad38c"><td class="memItemLeft" align="right" valign="top"><a id="a571ffa12b5390630c2f89f0e19bad38c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a571ffa12b5390630c2f89f0e19bad38c">scarc_allocate_bmatrix</a> (A, NL, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:a571ffa12b5390630c2f89f0e19bad38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate matrix in bandwise storage format. <br /></td></tr>
<tr class="separator:a571ffa12b5390630c2f89f0e19bad38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dc5647f4c36494438237bd0ba576e2"><td class="memItemLeft" align="right" valign="top"><a id="af1dc5647f4c36494438237bd0ba576e2"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#af1dc5647f4c36494438237bd0ba576e2">scarc_deallocate_bmatrix</a> (A, CNAME, CSCOPE)</td></tr>
<tr class="memdesc:af1dc5647f4c36494438237bd0ba576e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate matrix in bandwise storage format. <br /></td></tr>
<tr class="separator:af1dc5647f4c36494438237bd0ba576e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7082ce138af8ce20ad417edc1c1b0fe2"><td class="memItemLeft" align="right" valign="top"><a id="a7082ce138af8ce20ad417edc1c1b0fe2"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a7082ce138af8ce20ad417edc1c1b0fe2">scarc_dump_csv</a> (ISM, NS, NL)</td></tr>
<tr class="memdesc:a7082ce138af8ce20ad417edc1c1b0fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump residual information. <br /></td></tr>
<tr class="separator:a7082ce138af8ce20ad417edc1c1b0fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5076fecdd908066f2df61168e33d4622"><td class="memItemLeft" align="right" valign="top"><a id="a5076fecdd908066f2df61168e33d4622"></a>
subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a5076fecdd908066f2df61168e33d4622">scarc_dump_timers</a></td></tr>
<tr class="memdesc:a5076fecdd908066f2df61168e33d4622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump CPU times of several routines. <br /></td></tr>
<tr class="separator:a5076fecdd908066f2df61168e33d4622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fca6f16e13e4c3d31996c0bb89f233"><td class="memItemLeft" align="right" valign="top"><a id="ad1fca6f16e13e4c3d31996c0bb89f233"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ad1fca6f16e13e4c3d31996c0bb89f233">scarc_store_mgm</a> (NL, NTYPE)</td></tr>
<tr class="memdesc:ad1fca6f16e13e4c3d31996c0bb89f233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store preliminary solution vector in McKeeney-Greengard-Mayo method. <br /></td></tr>
<tr class="separator:ad1fca6f16e13e4c3d31996c0bb89f233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe38edca69a1065b9886f5e310bd43a1"><td class="memItemLeft" align="right" valign="top"><a id="afe38edca69a1065b9886f5e310bd43a1"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#afe38edca69a1065b9886f5e310bd43a1">scarc_mgm_internal_velocity</a> (NL)</td></tr>
<tr class="memdesc:afe38edca69a1065b9886f5e310bd43a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set internal boundary conditions for unstructured, homogeneous part of McKeeney-Greengard-Mayo method. <br /></td></tr>
<tr class="separator:afe38edca69a1065b9886f5e310bd43a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06b08f231963b4cd3431fd53ee20be5"><td class="memItemLeft" align="right" valign="top"><a id="ae06b08f231963b4cd3431fd53ee20be5"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae06b08f231963b4cd3431fd53ee20be5">scarc_setup_mgm</a> (NLMIN, NLMAX)</td></tr>
<tr class="memdesc:ae06b08f231963b4cd3431fd53ee20be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate velocity vectors for the setting of internal boundary conditions in McKeeney-Greengard-Mayo method. <br /></td></tr>
<tr class="separator:ae06b08f231963b4cd3431fd53ee20be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af882bc364e7fbe3c826e982c555634da"><td class="memItemLeft" align="right" valign="top"><a id="af882bc364e7fbe3c826e982c555634da"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#af882bc364e7fbe3c826e982c555634da">scarc_setup_mgm_lu</a> (NM, NL)</td></tr>
<tr class="memdesc:af882bc364e7fbe3c826e982c555634da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup LU-decomposition for McKeeney-Greengard-Mayo method. <br /></td></tr>
<tr class="separator:af882bc364e7fbe3c826e982c555634da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1235d8463128c3b41a97d2e7ab92405"><td class="memItemLeft" align="right" valign="top"><a id="ae1235d8463128c3b41a97d2e7ab92405"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae1235d8463128c3b41a97d2e7ab92405">scarc_setup_mgm_ilu</a> (NM, NL)</td></tr>
<tr class="memdesc:ae1235d8463128c3b41a97d2e7ab92405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup ILU-decomposition for McKeeney-Greengard-Mayo method. <br /></td></tr>
<tr class="separator:ae1235d8463128c3b41a97d2e7ab92405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf43e2f72ef77d9875a226e455cb00b"><td class="memItemLeft" align="right" valign="top"><a id="a2bf43e2f72ef77d9875a226e455cb00b"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a2bf43e2f72ef77d9875a226e455cb00b">scarc_method_mgm_lu</a> (NM, NL)</td></tr>
<tr class="memdesc:a2bf43e2f72ef77d9875a226e455cb00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform LU-decomposition for McKeeney-Greengard-Mayo method. <br /></td></tr>
<tr class="separator:a2bf43e2f72ef77d9875a226e455cb00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad328a422de0c460586eacf5e2645d8be"><td class="memItemLeft" align="right" valign="top"><a id="ad328a422de0c460586eacf5e2645d8be"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ad328a422de0c460586eacf5e2645d8be">scarc_method_mgm_ilu</a> (NM, NL)</td></tr>
<tr class="memdesc:ad328a422de0c460586eacf5e2645d8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform ILU-decomposition for McKeeney-Greengard-Mayo method. <br /></td></tr>
<tr class="separator:ad328a422de0c460586eacf5e2645d8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c36b3ba5a4edb679338ef15ba492c6"><td class="memItemLeft" align="right" valign="top"><a id="a69c36b3ba5a4edb679338ef15ba492c6"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a69c36b3ba5a4edb679338ef15ba492c6">scarc_dump_quantity</a> (NV, CNAME, ISM, NS, NL)</td></tr>
<tr class="memdesc:a69c36b3ba5a4edb679338ef15ba492c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging version only: Dump out information for specified quantity. <br /></td></tr>
<tr class="separator:a69c36b3ba5a4edb679338ef15ba492c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620606a50a1c7c20359c7490866d1e54"><td class="memItemLeft" align="right" valign="top"><a id="a620606a50a1c7c20359c7490866d1e54"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a620606a50a1c7c20359c7490866d1e54">scarc_debug_int1</a> (ARR, I1, I2, CNAME, CTEXT)</td></tr>
<tr class="memdesc:a620606a50a1c7c20359c7490866d1e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging version only: Print out debug information for integer vector. <br /></td></tr>
<tr class="separator:a620606a50a1c7c20359c7490866d1e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f21ed217e7cdc10a8269bb10711990"><td class="memItemLeft" align="right" valign="top"><a id="a46f21ed217e7cdc10a8269bb10711990"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a46f21ed217e7cdc10a8269bb10711990">scarc_debug_real1</a> (ARR, I1, I2, CNAME, CTEXT)</td></tr>
<tr class="memdesc:a46f21ed217e7cdc10a8269bb10711990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging version only: Print out debug information for double precision vector. <br /></td></tr>
<tr class="separator:a46f21ed217e7cdc10a8269bb10711990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073f7bd72cbc226a036336a5d21fb015"><td class="memItemLeft" align="right" valign="top"><a id="a073f7bd72cbc226a036336a5d21fb015"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a073f7bd72cbc226a036336a5d21fb015">scarc_debug_zones</a> (G, IC, ITYPE, CTEXT)</td></tr>
<tr class="memdesc:a073f7bd72cbc226a036336a5d21fb015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging version only: Print out debug information for aggregation zones. <br /></td></tr>
<tr class="separator:a073f7bd72cbc226a036336a5d21fb015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cd7e671cd3bad3352866985417937c"><td class="memItemLeft" align="right" valign="top"><a id="ac6cd7e671cd3bad3352866985417937c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac6cd7e671cd3bad3352866985417937c">scarc_debug_cmatrix</a> (A, CNAME, CTEXT)</td></tr>
<tr class="memdesc:ac6cd7e671cd3bad3352866985417937c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging version only: Print out debug information for compactly stored matrix. <br /></td></tr>
<tr class="separator:ac6cd7e671cd3bad3352866985417937c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cc9a49696ebf59427efe449a736d83"><td class="memItemLeft" align="right" valign="top"><a id="ac8cc9a49696ebf59427efe449a736d83"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ac8cc9a49696ebf59427efe449a736d83">scarc_debug_level</a> (NV, CVEC, NL)</td></tr>
<tr class="memdesc:ac8cc9a49696ebf59427efe449a736d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging version only: Print out debug information for specified vector. <br /></td></tr>
<tr class="separator:ac8cc9a49696ebf59427efe449a736d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6feb419abe6d39c356ed9da8fc4a4a"><td class="memItemLeft" align="right" valign="top"><a id="aad6feb419abe6d39c356ed9da8fc4a4a"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aad6feb419abe6d39c356ed9da8fc4a4a">scarc_debug_quantity</a> (NTYPE, NL, CQUANTITY)</td></tr>
<tr class="memdesc:aad6feb419abe6d39c356ed9da8fc4a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging version only: Print out debug information for specified quantity. <br /></td></tr>
<tr class="separator:aad6feb419abe6d39c356ed9da8fc4a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb880f4fa4240dbd787c5422c5509a07"><td class="memItemLeft" align="right" valign="top"><a id="aeb880f4fa4240dbd787c5422c5509a07"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aeb880f4fa4240dbd787c5422c5509a07">scarc_matlab_vector</a> (NV, CVEC, NL)</td></tr>
<tr class="memdesc:aeb880f4fa4240dbd787c5422c5509a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging version only: Print out vector information on specified level for MATLAB. <br /></td></tr>
<tr class="separator:aeb880f4fa4240dbd787c5422c5509a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21677601e49bd9470cb425c188795605"><td class="memItemLeft" align="right" valign="top"><a id="a21677601e49bd9470cb425c188795605"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a21677601e49bd9470cb425c188795605">scarc_matlab_matrix</a> (VAL, ROW, COL, NC1, NC2, NM, NL, CNAME)</td></tr>
<tr class="memdesc:a21677601e49bd9470cb425c188795605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging version only: Print out matrix information on specified level for MATLAB. <br /></td></tr>
<tr class="separator:a21677601e49bd9470cb425c188795605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdf53e69dcc0f55c53e47bce2f98a77"><td class="memItemLeft" align="right" valign="top"><a id="a0cdf53e69dcc0f55c53e47bce2f98a77"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a0cdf53e69dcc0f55c53e47bce2f98a77">scarc_python_matrix</a> (NL, CNAME)</td></tr>
<tr class="memdesc:a0cdf53e69dcc0f55c53e47bce2f98a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging version only: Print out matrix information on specified level for PYTHON. <br /></td></tr>
<tr class="separator:a0cdf53e69dcc0f55c53e47bce2f98a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6063327cb64b241552283e47b5b839bf"><td class="memItemLeft" align="right" valign="top"><a id="a6063327cb64b241552283e47b5b839bf"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a6063327cb64b241552283e47b5b839bf">scarc_python_zones</a> (NM, NL, CNAME)</td></tr>
<tr class="memdesc:a6063327cb64b241552283e47b5b839bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging version only: Print out aggregation zones information on specified level for PYTHON. <br /></td></tr>
<tr class="separator:a6063327cb64b241552283e47b5b839bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96b760d37ff8e697abbcb10c3656fef"><td class="memItemLeft" align="right" valign="top"><a id="ab96b760d37ff8e697abbcb10c3656fef"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab96b760d37ff8e697abbcb10c3656fef">scarc_blender_zones</a> (NM, NL)</td></tr>
<tr class="memdesc:ab96b760d37ff8e697abbcb10c3656fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging version only: Print out matrix information on specified level for BLENDER. <br /></td></tr>
<tr class="separator:ab96b760d37ff8e697abbcb10c3656fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80713e9ae2ed80860823b524c3bc43f"><td class="memItemLeft" align="right" valign="top"><a id="ab80713e9ae2ed80860823b524c3bc43f"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab80713e9ae2ed80860823b524c3bc43f">scarc_preset_b1_case</a></td></tr>
<tr class="memdesc:ab80713e9ae2ed80860823b524c3bc43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporarily preset B1 case with specified aggregation pattern. <br /></td></tr>
<tr class="separator:ab80713e9ae2ed80860823b524c3bc43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef5df839e3588da24682188b6be869b"><td class="memItemLeft" align="right" valign="top"><a id="a9ef5df839e3588da24682188b6be869b"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a9ef5df839e3588da24682188b6be869b">scarc_preset_b14_case</a></td></tr>
<tr class="memdesc:a9ef5df839e3588da24682188b6be869b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporarily preset B14 case with specified aggregation pattern. <br /></td></tr>
<tr class="separator:a9ef5df839e3588da24682188b6be869b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66a5fe7041d40ffde847a302897f0c5"><td class="memItemLeft" align="right" valign="top"><a id="ad66a5fe7041d40ffde847a302897f0c5"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ad66a5fe7041d40ffde847a302897f0c5">scarc_preset_b14big_case</a></td></tr>
<tr class="memdesc:ad66a5fe7041d40ffde847a302897f0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporarily preset B14_BIG case with specified aggregation pattern. <br /></td></tr>
<tr class="separator:ad66a5fe7041d40ffde847a302897f0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40529bdbaa0bbeb8503056b1d3a223f1"><td class="memItemLeft" align="right" valign="top"><a id="a40529bdbaa0bbeb8503056b1d3a223f1"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a40529bdbaa0bbeb8503056b1d3a223f1">scarc_dump_system</a> (NSTACK, ITYPE)</td></tr>
<tr class="memdesc:a40529bdbaa0bbeb8503056b1d3a223f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standalone version only: Dump matrix and vectors belonging to pressure system. <br /></td></tr>
<tr class="separator:a40529bdbaa0bbeb8503056b1d3a223f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42aae7b07d0e3c6962c08fb782ad00c5"><td class="memItemLeft" align="right" valign="top"><a id="a42aae7b07d0e3c6962c08fb782ad00c5"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a42aae7b07d0e3c6962c08fb782ad00c5">scarc_dump_environment</a></td></tr>
<tr class="memdesc:a42aae7b07d0e3c6962c08fb782ad00c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standalone version only: Dump several arrays and structures needed for the standalone version of ScaRC. <br /></td></tr>
<tr class="separator:a42aae7b07d0e3c6962c08fb782ad00c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82778456a6945d5d94edf79d6ab3b3c"><td class="memItemLeft" align="right" valign="top"><a id="af82778456a6945d5d94edf79d6ab3b3c"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#af82778456a6945d5d94edf79d6ab3b3c">scarc_restore_environment</a></td></tr>
<tr class="memdesc:af82778456a6945d5d94edf79d6ab3b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standalone version only: Dump several arrays and structures needed for ScaRC - standalone version. <br /></td></tr>
<tr class="separator:af82778456a6945d5d94edf79d6ab3b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f23c382a1805c3af7931051e6200efd"><td class="memItemLeft" align="right" valign="top"><a id="a3f23c382a1805c3af7931051e6200efd"></a>
subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a3f23c382a1805c3af7931051e6200efd">scarc_setup_pressure</a> ()</td></tr>
<tr class="memdesc:a3f23c382a1805c3af7931051e6200efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standalone version only: Allocate and initialize vectors pressure diagnostics - only for developping purposes. <br /></td></tr>
<tr class="separator:a3f23c382a1805c3af7931051e6200efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af310021670f8c679935a3ab453b35c73"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#af310021670f8c679935a3ab453b35c73">scarc_pressure_difference</a> (NL)</td></tr>
<tr class="memdesc:af310021670f8c679935a3ab453b35c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standalone version only: Compute Differences between old and new pressure solutions - only for developping purposes.  <a href="namespacescrc.html#af310021670f8c679935a3ab453b35c73">More...</a><br /></td></tr>
<tr class="separator:af310021670f8c679935a3ab453b35c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:adea362fb24b59b0261baf879678f853b"><td class="memItemLeft" align="right" valign="top"><a id="adea362fb24b59b0261baf879678f853b"></a>
type(scarc_type), dimension(:), allocatable, target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#adea362fb24b59b0261baf879678f853b">scarc</a></td></tr>
<tr class="memdesc:adea362fb24b59b0261baf879678f853b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main ScaRC data structure. <br /></td></tr>
<tr class="separator:adea362fb24b59b0261baf879678f853b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ec582ed601073e99bc6ffd0d8b6693"><td class="memItemLeft" align="right" valign="top"><a id="a69ec582ed601073e99bc6ffd0d8b6693"></a>
type(scarc_stack_type), dimension(:), allocatable, target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a69ec582ed601073e99bc6ffd0d8b6693">stack</a></td></tr>
<tr class="memdesc:a69ec582ed601073e99bc6ffd0d8b6693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack of consecutive solvers. <br /></td></tr>
<tr class="separator:a69ec582ed601073e99bc6ffd0d8b6693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d19ff6a4a73dce7b7e668666496722"><td class="memItemLeft" align="right" valign="top"><a id="a53d19ff6a4a73dce7b7e668666496722"></a>
type(scarc_cpu_type), dimension(:), allocatable, target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a53d19ff6a4a73dce7b7e668666496722">cpu</a></td></tr>
<tr class="memdesc:a53d19ff6a4a73dce7b7e668666496722"><td class="mdescLeft">&#160;</td><td class="mdescRight">CPU-times of different routines. <br /></td></tr>
<tr class="separator:a53d19ff6a4a73dce7b7e668666496722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c0f42c2c7af026701208d145cf7727"><td class="memItemLeft" align="right" valign="top"><a id="a15c0f42c2c7af026701208d145cf7727"></a>
type(scarc_memory_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a15c0f42c2c7af026701208d145cf7727">memory</a></td></tr>
<tr class="memdesc:a15c0f42c2c7af026701208d145cf7727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory administration for ScaRC arrays. <br /></td></tr>
<tr class="separator:a15c0f42c2c7af026701208d145cf7727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75da452afefbf2530fea31dae3e8d431"><td class="memItemLeft" align="right" valign="top"><a id="a75da452afefbf2530fea31dae3e8d431"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a75da452afefbf2530fea31dae3e8d431">main_cg</a></td></tr>
<tr class="memdesc:a75da452afefbf2530fea31dae3e8d431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for Krylov main solver. <br /></td></tr>
<tr class="separator:a75da452afefbf2530fea31dae3e8d431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3950333ff372fdd2db2cdcaa123f2981"><td class="memItemLeft" align="right" valign="top"><a id="a3950333ff372fdd2db2cdcaa123f2981"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a3950333ff372fdd2db2cdcaa123f2981">main_cg_structured</a></td></tr>
<tr class="memdesc:a3950333ff372fdd2db2cdcaa123f2981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for structured Krylov main solver. <br /></td></tr>
<tr class="separator:a3950333ff372fdd2db2cdcaa123f2981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99fca9c9823bf9244ba59d171e15ede"><td class="memItemLeft" align="right" valign="top"><a id="af99fca9c9823bf9244ba59d171e15ede"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#af99fca9c9823bf9244ba59d171e15ede">main_cg_unstructured</a></td></tr>
<tr class="memdesc:af99fca9c9823bf9244ba59d171e15ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for unstructured Krylov main solver. <br /></td></tr>
<tr class="separator:af99fca9c9823bf9244ba59d171e15ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883fdba2b0011e016b3b4895c4d3c02c"><td class="memItemLeft" align="right" valign="top"><a id="a883fdba2b0011e016b3b4895c4d3c02c"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a883fdba2b0011e016b3b4895c4d3c02c">main_gmg</a></td></tr>
<tr class="memdesc:a883fdba2b0011e016b3b4895c4d3c02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for Multigrid main solver. <br /></td></tr>
<tr class="separator:a883fdba2b0011e016b3b4895c4d3c02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e78eae341abe388ff9eca9906a5696"><td class="memItemLeft" align="right" valign="top"><a id="a13e78eae341abe388ff9eca9906a5696"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a13e78eae341abe388ff9eca9906a5696">coarse_krylov</a></td></tr>
<tr class="memdesc:a13e78eae341abe388ff9eca9906a5696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for Krylov coarse grid solver. <br /></td></tr>
<tr class="separator:a13e78eae341abe388ff9eca9906a5696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdea14b0bee5b569580a049a485ec451"><td class="memItemLeft" align="right" valign="top"><a id="acdea14b0bee5b569580a049a485ec451"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#acdea14b0bee5b569580a049a485ec451">main_lu</a></td></tr>
<tr class="memdesc:acdea14b0bee5b569580a049a485ec451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for LU-decomposition main solver. <br /></td></tr>
<tr class="separator:acdea14b0bee5b569580a049a485ec451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf004adfd407db05133d8d564fd75b64"><td class="memItemLeft" align="right" valign="top"><a id="aaf004adfd407db05133d8d564fd75b64"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aaf004adfd407db05133d8d564fd75b64">coarse_cluster</a></td></tr>
<tr class="memdesc:aaf004adfd407db05133d8d564fd75b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for CLUSTER_SPARSE_SOLVER coarse grid solver. <br /></td></tr>
<tr class="separator:aaf004adfd407db05133d8d564fd75b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf4733089254c083360670116231506"><td class="memItemLeft" align="right" valign="top"><a id="accf4733089254c083360670116231506"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#accf4733089254c083360670116231506">coarse_pardiso</a></td></tr>
<tr class="memdesc:accf4733089254c083360670116231506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for PARDISO coarse grid solver. <br /></td></tr>
<tr class="separator:accf4733089254c083360670116231506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc27f0e0c2eeeea5c2161ab02689e994"><td class="memItemLeft" align="right" valign="top"><a id="abc27f0e0c2eeeea5c2161ab02689e994"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#abc27f0e0c2eeeea5c2161ab02689e994">precon_jac</a></td></tr>
<tr class="memdesc:abc27f0e0c2eeeea5c2161ab02689e994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for Jacobi preconditioner. <br /></td></tr>
<tr class="separator:abc27f0e0c2eeeea5c2161ab02689e994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6218adb4a3e90ac46d99e88ee7719aa"><td class="memItemLeft" align="right" valign="top"><a id="aa6218adb4a3e90ac46d99e88ee7719aa"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#aa6218adb4a3e90ac46d99e88ee7719aa">precon_ssor</a></td></tr>
<tr class="memdesc:aa6218adb4a3e90ac46d99e88ee7719aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for SSOR preconditioner. <br /></td></tr>
<tr class="separator:aa6218adb4a3e90ac46d99e88ee7719aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878966962d3ac633990ec5eef09de420"><td class="memItemLeft" align="right" valign="top"><a id="a878966962d3ac633990ec5eef09de420"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a878966962d3ac633990ec5eef09de420">precon_ilu</a></td></tr>
<tr class="memdesc:a878966962d3ac633990ec5eef09de420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for ILU preconditioner. <br /></td></tr>
<tr class="separator:a878966962d3ac633990ec5eef09de420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a214124aa5b645711833c57598b701"><td class="memItemLeft" align="right" valign="top"><a id="a39a214124aa5b645711833c57598b701"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a39a214124aa5b645711833c57598b701">precon_fft</a></td></tr>
<tr class="memdesc:a39a214124aa5b645711833c57598b701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for FFT preconditioner. <br /></td></tr>
<tr class="separator:a39a214124aa5b645711833c57598b701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7617b4697159ac142a617f593cb1c444"><td class="memItemLeft" align="right" valign="top"><a id="a7617b4697159ac142a617f593cb1c444"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a7617b4697159ac142a617f593cb1c444">precon_ffto</a></td></tr>
<tr class="memdesc:a7617b4697159ac142a617f593cb1c444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for FFTO preconditioner (including overlap) <br /></td></tr>
<tr class="separator:a7617b4697159ac142a617f593cb1c444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605dad3bb4c3f380f7fce119ffb02d90"><td class="memItemLeft" align="right" valign="top"><a id="a605dad3bb4c3f380f7fce119ffb02d90"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a605dad3bb4c3f380f7fce119ffb02d90">precon_mg</a></td></tr>
<tr class="memdesc:a605dad3bb4c3f380f7fce119ffb02d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for Multigrid preconditioner. <br /></td></tr>
<tr class="separator:a605dad3bb4c3f380f7fce119ffb02d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc10e2b7580c9f6a2d4f0c4f862ccb40"><td class="memItemLeft" align="right" valign="top"><a id="afc10e2b7580c9f6a2d4f0c4f862ccb40"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#afc10e2b7580c9f6a2d4f0c4f862ccb40">precon_mjac</a></td></tr>
<tr class="memdesc:afc10e2b7580c9f6a2d4f0c4f862ccb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for Jacobi preconditioner (matrix version) <br /></td></tr>
<tr class="separator:afc10e2b7580c9f6a2d4f0c4f862ccb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4490e4951b74b3d95668b82a5cee832b"><td class="memItemLeft" align="right" valign="top"><a id="a4490e4951b74b3d95668b82a5cee832b"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a4490e4951b74b3d95668b82a5cee832b">precon_mgs</a></td></tr>
<tr class="memdesc:a4490e4951b74b3d95668b82a5cee832b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for Gauss-Seidel preconditioner (matrix version) <br /></td></tr>
<tr class="separator:a4490e4951b74b3d95668b82a5cee832b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9cc3f7c9eb7e6cd6c2bb871ae321b0"><td class="memItemLeft" align="right" valign="top"><a id="a6a9cc3f7c9eb7e6cd6c2bb871ae321b0"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a6a9cc3f7c9eb7e6cd6c2bb871ae321b0">precon_msgs</a></td></tr>
<tr class="memdesc:a6a9cc3f7c9eb7e6cd6c2bb871ae321b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for Sym. Gauss-Seidel preconditioner (matrix vs.) <br /></td></tr>
<tr class="separator:a6a9cc3f7c9eb7e6cd6c2bb871ae321b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e640d9989f2fa6fb48772d67f704274"><td class="memItemLeft" align="right" valign="top"><a id="a5e640d9989f2fa6fb48772d67f704274"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a5e640d9989f2fa6fb48772d67f704274">precon_msor</a></td></tr>
<tr class="memdesc:a5e640d9989f2fa6fb48772d67f704274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for SOR preconditioner (matrix version) <br /></td></tr>
<tr class="separator:a5e640d9989f2fa6fb48772d67f704274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1116e0f39e2291b4608262d5133238d"><td class="memItemLeft" align="right" valign="top"><a id="ae1116e0f39e2291b4608262d5133238d"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae1116e0f39e2291b4608262d5133238d">precon_mssor</a></td></tr>
<tr class="memdesc:ae1116e0f39e2291b4608262d5133238d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for SSOR preconditioner (matrix version) <br /></td></tr>
<tr class="separator:ae1116e0f39e2291b4608262d5133238d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7abb0943dee33e80e22a51ebbf18cf"><td class="memItemLeft" align="right" valign="top"><a id="a1a7abb0943dee33e80e22a51ebbf18cf"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a1a7abb0943dee33e80e22a51ebbf18cf">smooth_jac</a></td></tr>
<tr class="memdesc:a1a7abb0943dee33e80e22a51ebbf18cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for Jacobi smoother. <br /></td></tr>
<tr class="separator:a1a7abb0943dee33e80e22a51ebbf18cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8237ad7bfebf272ec49fdd58d497727"><td class="memItemLeft" align="right" valign="top"><a id="ae8237ad7bfebf272ec49fdd58d497727"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ae8237ad7bfebf272ec49fdd58d497727">smooth_ssor</a></td></tr>
<tr class="memdesc:ae8237ad7bfebf272ec49fdd58d497727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for SSOR smoother. <br /></td></tr>
<tr class="separator:ae8237ad7bfebf272ec49fdd58d497727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174065d77552f644aab724542c11f342"><td class="memItemLeft" align="right" valign="top"><a id="a174065d77552f644aab724542c11f342"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a174065d77552f644aab724542c11f342">smooth_ilu</a></td></tr>
<tr class="memdesc:a174065d77552f644aab724542c11f342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for ILU smoother. <br /></td></tr>
<tr class="separator:a174065d77552f644aab724542c11f342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62e590f53a39e35320075c871c27b97"><td class="memItemLeft" align="right" valign="top"><a id="ab62e590f53a39e35320075c871c27b97"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab62e590f53a39e35320075c871c27b97">smooth_fft</a></td></tr>
<tr class="memdesc:ab62e590f53a39e35320075c871c27b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for FFT smoother. <br /></td></tr>
<tr class="separator:ab62e590f53a39e35320075c871c27b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3176d5d163b745f714ff6e60ba0b4c85"><td class="memItemLeft" align="right" valign="top"><a id="a3176d5d163b745f714ff6e60ba0b4c85"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a3176d5d163b745f714ff6e60ba0b4c85">smooth_ffto</a></td></tr>
<tr class="memdesc:a3176d5d163b745f714ff6e60ba0b4c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for FFTO smoother (including overlap) <br /></td></tr>
<tr class="separator:a3176d5d163b745f714ff6e60ba0b4c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75876d8b6307acefc9e772a369a23041"><td class="memItemLeft" align="right" valign="top"><a id="a75876d8b6307acefc9e772a369a23041"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a75876d8b6307acefc9e772a369a23041">smooth_mjac</a></td></tr>
<tr class="memdesc:a75876d8b6307acefc9e772a369a23041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for Jacobi smoother (matrix version) <br /></td></tr>
<tr class="separator:a75876d8b6307acefc9e772a369a23041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9b1238a5def298db4bbd5200368c42"><td class="memItemLeft" align="right" valign="top"><a id="a5e9b1238a5def298db4bbd5200368c42"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a5e9b1238a5def298db4bbd5200368c42">smooth_mgs</a></td></tr>
<tr class="memdesc:a5e9b1238a5def298db4bbd5200368c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for Gauss-Seidel smoother (matrix version) <br /></td></tr>
<tr class="separator:a5e9b1238a5def298db4bbd5200368c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c50d79998bf72a14f7c01603e762148"><td class="memItemLeft" align="right" valign="top"><a id="a3c50d79998bf72a14f7c01603e762148"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a3c50d79998bf72a14f7c01603e762148">smooth_msgs</a></td></tr>
<tr class="memdesc:a3c50d79998bf72a14f7c01603e762148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for Sym. Gauss-Seidel smoother (matrix vs.) <br /></td></tr>
<tr class="separator:a3c50d79998bf72a14f7c01603e762148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6498bd7bdd438a3e84f052a51a4e951b"><td class="memItemLeft" align="right" valign="top"><a id="a6498bd7bdd438a3e84f052a51a4e951b"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a6498bd7bdd438a3e84f052a51a4e951b">smooth_msor</a></td></tr>
<tr class="memdesc:a6498bd7bdd438a3e84f052a51a4e951b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for SOR smoother (matrix version) <br /></td></tr>
<tr class="separator:a6498bd7bdd438a3e84f052a51a4e951b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e81cb9f57a72c3a3331e424fb316239"><td class="memItemLeft" align="right" valign="top"><a id="a8e81cb9f57a72c3a3331e424fb316239"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a8e81cb9f57a72c3a3331e424fb316239">smooth_mssor</a></td></tr>
<tr class="memdesc:a8e81cb9f57a72c3a3331e424fb316239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for SSOR smoother (matrix version) <br /></td></tr>
<tr class="separator:a8e81cb9f57a72c3a3331e424fb316239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981d3b1025c77d81b3bbd292bcd47195"><td class="memItemLeft" align="right" valign="top"><a id="a981d3b1025c77d81b3bbd292bcd47195"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a981d3b1025c77d81b3bbd292bcd47195">precon_mkl</a></td></tr>
<tr class="memdesc:a981d3b1025c77d81b3bbd292bcd47195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for MKL preconditioner. <br /></td></tr>
<tr class="separator:a981d3b1025c77d81b3bbd292bcd47195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6612d0539a417d54de979fa62f8982"><td class="memItemLeft" align="right" valign="top"><a id="a3c6612d0539a417d54de979fa62f8982"></a>
type(scarc_solver_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a3c6612d0539a417d54de979fa62f8982">smooth_mkl</a></td></tr>
<tr class="memdesc:a3c6612d0539a417d54de979fa62f8982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver structure for MKL smoother. <br /></td></tr>
<tr class="separator:a3c6612d0539a417d54de979fa62f8982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25951be34d9df4b88e596bfafeb57394"><td class="memItemLeft" align="right" valign="top"><a id="a25951be34d9df4b88e596bfafeb57394"></a>
type(scarc_message_type), save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#a25951be34d9df4b88e596bfafeb57394">msg</a></td></tr>
<tr class="memdesc:a25951be34d9df4b88e596bfafeb57394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to print out various messages. <br /></td></tr>
<tr class="separator:a25951be34d9df4b88e596bfafeb57394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81f3f6a75a7ba38389b5f0caf873733"><td class="memItemLeft" align="right" valign="top"><a id="ab81f3f6a75a7ba38389b5f0caf873733"></a>
type(scarc_subdivision_type), target, save&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescrc.html#ab81f3f6a75a7ba38389b5f0caf873733">subdivision</a></td></tr>
<tr class="memdesc:ab81f3f6a75a7ba38389b5f0caf873733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to keep information about subdivision. <br /></td></tr>
<tr class="separator:ab81f3f6a75a7ba38389b5f0caf873733"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Alternative solution of the FDS pressure equation by Scalable Recursive Clustering (ScaRC) </p>
<p>Collection of Poisson solvers based on iterative parallel solution strategies (Krylov and multigrid solvers) </p>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="af310021670f8c679935a3ab453b35c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af310021670f8c679935a3ab453b35c73">&#9670;&nbsp;</a></span>scarc_pressure_difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine scrc::scarc_pressure_difference </td>
          <td>(</td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>NL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standalone version only: Compute Differences between old and new pressure solutions - only for developping purposes. </p>
<p>Standalone version only: Store new pressure vector for comparison in next time step</p>

</div>
</div>
<a id="abc29c459979a0688a49272d661cec31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc29c459979a0688a49272d661cec31a">&#9670;&nbsp;</a></span>scarc_update_ghostcells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine scrc::scarc_update_ghostcells </td>
          <td>(</td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>NL</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set correct boundary values at external and internal boundaries. </p>
<p>Perform data exchange to achieve consistency of ghost values along internal boundaries</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.19
</small></address>
</body>
</html>
